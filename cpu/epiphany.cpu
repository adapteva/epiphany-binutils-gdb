; Adapteva EPIPHANY CPU description. -*- Scheme -*-
; Copyright 1998, 1999, 2000, 2001, 2003, 2006, 2007, 2008, 2009, 2010, 2011
; Free Software Foundation, Inc.
;
; Contributed by Embecosm on behalf of Adapteva, Inc.
; This file is part of the GNU Binutils and of GDB.
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
; MA 02110-1301, USA.

(define-rtl-version 0 9)

(include "simplify.inc")
					; define-arch must appear first

(define-arch
  (name epiphany) ; name of cpu family
  (comment "Adapteva, Inc. EPIPHANY family")
  (default-alignment aligned)
  (insn-lsb0? #t)

					; - a 16/32 bit instruction machine (the default)

  (machs epiphany32)
  (isas epiphany)
  )

					; Attributes.

(define-attr
  (for insn)
  (type boolean)
  (name SHORT-INSN)
  (comment "instruction is a 16 bit form")
  )

;; 3 bit add/sub immediate forms - useful for relaxing into 11 bit form
(define-attr
  (for insn)
  (type boolean)
  (name IMM3)
  (comment "instruction has a 3 bit immediate form")
  )

;; 8 bit mov immediate forms - useful for relaxing into 16 bit form
(define-attr
  (for insn)
  (type boolean)
  (name IMM8)
  (comment "instruction has a 8 bit immediate form")
  )

					; Instruction set parameters.

(define-isa
  (name epiphany)
  (comment "Adapteva, Inc. EPIPHANY32 ISA")

  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
  (decode-assist (3 2 1 0))  ; CGEN can figure this out
  (liw-insns 1)				; # instructions fetched at once
  )

					; Cpu family definitions.


(define-cpu
					; cpu names must be distinct from the architecture name and machine names.
  (name epiphanybf)
  (comment "Adapteva, Inc. EPIPHANY Family")
  (endian little)
  (word-bitsize 32)
  )

(define-cpu
  (name epiphanymf)
  (comment "Adapteva, Inc. EPIPHANY Family")
  (endian little)
  (word-bitsize 32)
  )


(define-mach
  (name epiphany32)
  (comment "Adapteva EPIPHANY")
  (cpu epiphanybf)
  )


					; Model descriptions.

(define-model
  (name epiphany32) (comment "Adapteva EPIPHANY 32/16") (attrs)
  (mach epiphany32)

  (unit u-exec "Execution Unit" ()
	1 1 ; issue done
	() ; state
	() ; inputs
	() ; outputs
	() ; profile action (default)
	)
  )



					; Instruction fields.
					;
					; Attributes:
					; XXX: what EPIPHANY attrs
					; PCREL-ADDR: pc relative value (for reloc and disassembly purposes)
					; ABS-ADDR: absolute address (for reloc and disassembly purposes?)
					; RESERVED: bits are not used to decode insn, must be all 0
					; RELOC: there is a relocation associated with this field

(define-attr
  (for ifield operand)
  (type boolean)
  (name RELOC)
  (comment "there is a reloc associated with this field (experiment)")
  )

;; define the fields of the instruction.
;;   name            description              ATTR  MSB LEN
(dnf f-opc        "primary opcode"             ()     3 4)
(dnf f-opc-4-1    "secondary opcode"           ()     4 1)
(dnf f-opc-6-3    "secondary opcode"           ()     6 3) ;;
(dnf f-opc-8-5    "tertiary opcode"            ()     8 5) ;;
(dnf f-opc-19-4   "additional opcode bits"     ()    19 4)
(dnf f-opc-9-6    "additional opcode bits"     ()     9 6)
(dnf f-opc-21-6   "additional opcode bits"     ()    21 6)
(dnf f-condcode   "condition codes"            ()     7 4)
(dnf f-secondary-ccs "flag for secondary ccs"  ()     7 1)
(dnf f-shift      "shift amount"               ()     9 5)
(dnf f-wordsize   "load/store size"            ()     6 2)
(dnf f-store      "load/store flag"            ()     4 1) ;; 0==load,1==store
(dnf f-opc-8-1    "opcode bits"                ()     8 1)
(dnf f-opc-31-32  "all opcode set"             ()     31 32)

(df f-simm8	  "branch displacement"   (PCREL-ADDR RELOC) 15 8 INT
    ((value pc) (sra SI (sub SI value pc) 1))
    ((value pc) (add SI (sll SI value 1) pc)))

(df f-simm24     "branch displacement"	  (PCREL-ADDR RELOC) 31 24 INT
    ((value pc) (sra SI (sub SI value pc) 1))
    ((value pc) (add SI (sll SI value 1) pc)))

(df f-sdisp3      "signed immediate 3 bit"     ()     9 3  INT #f #f)

(dnf f-disp3      "address offset"             ()     9 3)
(dnf f-disp8      "address offset"             ()    23 8)

(dnf f-imm8       "move/add/sub imm8"          ()    12 8)
(dnf f-imm-27-8   "move/add/sub imm16"         ()    27 8)
(dnf f-addsubx    "+/- index address"          ()    20 1)
(dnf f-subd       "+/- displ address"          ()    24 1)
(dnf f-pm         "post-modify immediate"      ()    25 1)

(dnf f-rm         "short rm"                   ()     9 3)   ;; RM
(dnf f-rn         "short rn"                   ()    12 3)   ;; RN
(dnf f-rd         "short rd"                   ()    15 3)   ;; RD

(dnf f-rm-x       "extension rm"               ()    25 3)   ;; RM
(dnf f-rn-x       "extension rn"               ()    28 3)   ;; RN
(dnf f-rd-x       "extension rd"               ()    31 3)   ;; RD

(dnf f-dc-9-1     "DC"                 (RESERVED)     9 1)

(dnf f-sn         "short sn"                   ()    12 3)   ;; SN
(dnf f-sd         "short sd"                   ()    15 3)   ;; SD

(dnf f-sn-x       "extension sn"               ()    28 3)   ;; SN
(dnf f-sd-x       "extension sd"               ()    31 3)   ;; SD

(dnf f-dc-7-4     "movts zeros"                ()     7 4)
(dnf f-trap-swi-9-1 "trap or swi"              ()     9 1)
(dnf f-gien-gidis-9-1 "gien or gidis"          ()     9 1)

(dnf f-mode4-l    "low 3 bits of mode4"        ()    15 3)
(dnf f-mode4-h    "high bit of mode4"          ()    29 1)

(dnf f-ctrlmode5  "atomic #imm5 ctrlmode"      ()    20 5)
(dnf f-atomic     "atomic bits"                ()    22 2)

(dnf f-dc-15-3    "DC"                 (RESERVED)    15 3)
(dnf f-dc-15-7    "DC"                 (RESERVED)    15 7)
(dnf f-dc-15-6    "DC"                         ()    15 6)
(dnf f-trap-num   "trap number"                ()    15 6)

(dnf f-dc-20-1    "DC"                 (RESERVED)    20 1)

(dnf f-dc-21-1    "DC"                 (RESERVED)    21 1)
(dnf f-dc-21-2    "DC"                 (RESERVED)    21 2)

(dnf f-dc-22-3    "DC"                 (RESERVED)    22 3)
(dnf f-dc-22-2    "DC"                 (RESERVED)    22 2)
(dnf f-dc-22-1    "DC"                 (RESERVED)    22 1)

(dnf f-dc-25-6    "DC"                 (RESERVED)    25 6)
(dnf f-dc-25-4    "DC"                 (RESERVED)    25 4)
(dnf f-dc-25-2    "DC"                 (RESERVED)    25 2)
(dnf f-dc-25-1    "DC"                 (RESERVED)    25 1)

(dnf f-dc-28-1    "DC"                 (RESERVED)    28 1)
(dnf f-dc-31-3    "DC"                 (RESERVED)    31 3)
(dnf f-dc-31-2    "DC"                 (RESERVED)    31 2)

(dnmf f-disp11 "Unsigned offset for load/store" () UINT (f-disp3 f-disp8)
      (sequence ()
		(set (ifield f-disp8) (and (srl (ifield f-disp11) 3) (const 255)))
		(set (ifield f-disp3) (and (ifield f-disp11) 7)))
      (sequence ()
		(set (ifield f-disp11) (or (sll (ifield f-disp8) 3)
					   (ifield f-disp3)))
		)
      )


(dnmf f-sdisp11 "Signed offset for load/store" () INT (f-disp3 f-disp8)
      (sequence ()			;encode
		(set (ifield f-disp8) (and #xff (srl SI (ifield f-sdisp11) 3)))
		(set (ifield f-disp3)  (and SI (ifield f-sdisp11) 7)))
      (sequence ()			;decode
		(set (ifield f-sdisp11)
		     (sra SI (sll SI (or SI (sll (ifield f-disp8) 3)
					 (ifield f-disp3))
				  21)
			  21)))
      )

(dnmf f-imm16 "Short immediate for move/add/sub" () UINT (f-imm8 f-imm-27-8)
      (sequence ()
		(set (ifield f-imm8) (and (ifield f-imm16) #xff))
		(set (ifield f-imm-27-8) (srl (ifield f-imm16) 8)))
      (sequence ()
		(set (ifield f-imm16) (or (sll (ifield f-imm-27-8) 8)
					  (ifield f-imm8))))
      )

;; TODO: It works but error output is confusing. Add a parse(?) handler.
(dnmf f-mode4 "Immediate for MODE" () UINT (f-mode4-l f-mode4-h)
  (sequence ()
    (set (ifield f-mode4-l) (and (ifield f-mode4) #x7))
    (set (ifield f-mode4-h) (srl (ifield f-mode4) #x3)))
  (sequence ()
    (set (ifield f-mode4)
      (or (sll (ifield f-mode4-h) #x3)
          (sll (ifield f-mode4-l) #x0))))
)

;; 32 bit instructions have the register number broken into two non-contiguous fields

(define-pmacro (x-reg-field reg)
  (define-multi-ifield
    (name (%sym "f-" reg "6"))
    (mode UINT)
    (subfields (%sym "f-" reg "-x") (%sym "f-" reg))
    (insert (sequence ()
		      (set (ifield (%sym "f-" reg))   (and (ifield (%sym "f-" reg "6"))
							   (const 7)))
		      (set (ifield (%sym "f-" reg "-x"))  (srl (ifield (%sym "f-" reg "6"))
							       (const 3)))
		      ))
    (extract (sequence ()
		       (set (ifield (%sym "f-" reg "6")) (or (sll (ifield (%sym "f-" reg "-x"))
								  (const 3))
							     (ifield (%sym "f-" reg))))
		       ))
    )
  )

(x-reg-field rd)			; f-rd6
(x-reg-field rn)			; f-rn6
(x-reg-field rm)			; f-rm6
(x-reg-field sd)			; f-sd6
(x-reg-field sn)			; f-sn6


;;;;;;;;;;
					; Enums. ;
;;;;;;;;;;

					; insn-opc: bits 3..0 - major family selector
(define-normal-insn-enum insn-opc "opc enums" () OP4_ f-opc
  (
   BRANCH16  ;; 0000
   LDSTR16X  ;; 0001
   FLOW16    ;; 0010
   IMM16     ;; 0011
   LDSTR16D  ;; 0100
   LDSTR16P  ;; 0101
   LSHIFT16  ;; 0110 - logical shift
   DSP16     ;; 0111 - 3 reg DSP 16 bit insns
   BRANCH    ;; 1000
   LDSTRX    ;; 1001
   ALU16     ;; 1010 - 3 reg 16 bit
   IMM32     ;; 1011
   LDSTRD    ;; 1100
   LDSTRP    ;; 1101
   ASHIFT16  ;; 1110   ASR, BITR
   MISC      ;; 1111 - 32 bit shifts, 3 reg ALU, 3 reg DSP, FLOW, BITR
   )
  )

(define-normal-insn-enum insn-wordsize "memory access width" () OPW_ f-wordsize
					; specifies the size of a memory load/store operation
  (BYTE SHORT WORD DOUBLE)
  )

(define-normal-insn-enum insn-memory-access "memory access direction" () OP_ f-store
					; load=0, store=1
  (LOAD STORE)
  )

(define-normal-insn-enum insn-atomicity
  "is atomic" ()
  OPA_ f-atomic
  (
    (TESTSET 1) ;; Legacy
    (ATOMIC  3)
  )
)

(define-normal-insn-enum insn-atomic-ctrlmode
  "atomic ctrlmode" ()
  OP_CTRLMODE_ f-ctrlmode5
  (
    (TESTSET   0)
  )
)

					; enum for trap codes used by simulator
(define-normal-insn-enum trap-codes "trap instruction dispatch code" () TRAP_ f-trap-num
  (write read open exit pass fail close other)
  )

					; cond branch: bits 7..4
					;
(define-normal-insn-enum insn-cond "branch conditions" () OPC_ f-condcode
  (EQ NE GTU GTEU LTEU LTU GT GTE LT LTE BEQ BNE BLT BLTE B BL))

					; dsp 3 operand opcodes
(define-normal-insn-enum insn-bop "binary operator subcodes" () OPB_ f-opc-6-3
  (EOR ADD LSL SUB LSR AND ASR ORR))

(define-normal-insn-enum insn-fop "floating operators" () OPF_ f-opc-6-3
  (ADD SUB MUL MADD MSUB FLOAT FIX FABS))

(define-normal-insn-enum insn-fopexn "extended floating operators" () OPF_ f-opc-6-3
  (- - - - - - - FMAX))

; Immediate operation secondary opcodes
(define-normal-insn-enum insn-immop "immediate operators" () OPI_ f-opc-6-3
  (- ADD - SUB - - - TRAP) ; TRAP is special extension for simulator
  )

					; don't care fields
(define-normal-insn-enum insn-dc-25-2 "don't cares" () OPI_25_2_ f-dc-25-2
  (MBZ))


(define-keyword
  (name all-reg-names)
  (comment "register num as per MMR map")
  (enum-prefix H-REG-)
  (name-prefix "")
  (values
	(NUM-REGS 512)
	; GPR group
	; some preferred aliases
	(IP 12) (SP 13) (LR 14) (FP 15)
	; the default register names
	(R0  0)  (R1   1) (R2   2) (R3   3) (R4   4) (R5   5) (R6   6) (R7   7)
	(R8  8)  (R9   9) (R10 10) (R11 11) (R12 12) (R13 13) (R14 14) (R15 15)
	(R16 16) (R17 17) (R18 18) (R19 19) (R20 20) (R21 21) (R22 22) (R23 23)
	(R24 24) (R25 25) (R26 26) (R27 27) (R28 28) (R29 29) (R30 30) (R31 31)
	(R32 32) (R33 33) (R34 34) (R35 35) (R36 36) (R37 37) (R38 38) (R39 39)
	(R40 40) (R41 41) (R42 42) (R43 43) (R44 44) (R45 45) (R46 46) (R47 47)
	(R48 48) (R49 49) (R50 50) (R51 51) (R52 52) (R53 53) (R54 54) (R55 55)
	(R56 56) (R57 57) (R58 58) (R59 59) (R60 60) (R61 61) (R62 62) (R63 63)
	; some less popular aliases
	(A1  0) (A2  1) (A3  2) (A4  3) (V1  4) (V2  5) (V3  6) (V4  7)
	(V5  8) (V6  9) (V7 10) (V8 11)
	(SB  9) (SL 10)

	;; SCR group
	(SCR-CONFIG      #x100) ;; configuration register
	(SCR-STATUS      #x101) ;; unified condition codes
	(SCR-PC          #x102) ;; program counter                        CORE  RD/WR*
	(SCR-DEBUGSTATUS #x103) ;; debug status register                  CORE  RD/WR     used by debugger tools only
	(SCR-IAB         #x104) ;; iab fifo register for external fetch   CORE  WR*       external instruction fetch return register. Don't use.
	(SCR-LC          #x105) ;; hw loop counter                        CORE  RD/WR
	(SCR-LS          #x106) ;; hardware loop start                    CORE  RD/WR
	(SCR-LE          #x107) ;; hardware loop end                      CORE  RD/WR
	(SCR-IRET        #x108) ;; interrupt return register              CORE  RD/WR
	(SCR-IMASK       #x109) ;; interrupt masking register             CORE  RD/WR
	(SCR-ILAT        #x10a) ;; interrupt latch register               CORE  RD/WR*
	(SCR-ILATST      #x10b) ;; interrupt latch register bit set       CORE  WR
	(SCR-ILATCL      #x10c) ;; interrupt latch register bit clear     CORE  WR
	(SCR-IPEND       #x10d) ;; interrupt servicing interrupts         CORE  RD/WR*
	(SCR-CTIMER0     #x10e) ;; event counter                          CORE  RD/WR
	(SCR-CTIMER1     #x10f) ;; event counter                          CORE  RD/WR
	(SCR-FSTATUS     #x110) ;; ?? flush status register (raw access?) CORE  WR
	(SCR-FCONFIG     #x111) ;; ?? flush config register (raw access?)
	(SCR-DEBUGCMD    #x112) ;; debug command register                 CORE  WR
	(SCR-SIMCMD      #x113) ;; simulator command register             SIM   WR

	;; DMA group
	(DMA0-CONFIG    #x140) ;; configuration register                 DMA   RD/WR
	(DMA0-STRIDE    #x141) ;; stride register                        DMA   RD/WR
	(DMA0-COUNT     #x142) ;; count register                         DMA   RD/WR
	(DMA0-SRCADDR   #x143) ;; source register                        DMA   RD/WR
	(DMA0-DSTADDR   #x144) ;; destination register                   DMA   RD/WR
	(DMA0-AUTO0     #x145) ;; autodma register                       DMA   RD/WR
	(DMA0-AUTO1     #x146) ;; autodma register                       DMA   RD/WR*
	(DMA0-STATUS    #x147) ;; dma status register                    DMA   RD/WR*
	(DMA1-CONFIG    #x148) ;; (samed as dma0*)
	(DMA1-STRIDE    #x149)
	(DMA1-COUNT     #x14a)
	(DMA1-SRCADDR   #x14b)
	(DMA1-DSTADDR   #x14c)
	(DMA1-AUTO0     #x14d)
	(DMA1-AUTO1     #x14e)
	(DMA1-STATUS    #x14f)

	;; Memory Protection Registers
	(MEM-CONFIG     #x180) ;; Forums: test register for the local SRAM (ignore, has not logical effect)
	(MEM-STATUS     #x181) ;; Memory protection status
	(MEM-PROTECT    #x182) ;; Memory protection configuration
	(MEM-RESERVE    #x183) ;; Forums: no idea should probably be removed :D

	;; MESH group
	(MESH-CONFIG         #x1c0) ;; mesh control register                 MESH   RD/WR
	(MESH-COREID         #x1c1) ;; mesh status and ID register           MESH   RD
	(MESH-MULTICAST      #x1c2) ;; multicast address                     MESH   RD/WR
	(MESH-RESETCORE      #x1c3) ;; core specific software reset                 WR
	(MESH-CMESHROUTE     #x1c4) ;; Not available on Epiphany-III
	(MESH-XMESHROUTE     #x1c5) ;; Not available on Epiphany-III
	(MESH-RMESHROUTE     #x1c6) ;; Not available on Epiphany-III
  )
)

(define-enum
  (name e-register-group-offsets)
  (comment "register group offsets in MMR region")
  (prefix H-REG-GRP-)
  (values
    (
	  ("GPR-OFFSET"      0) ;; General Purpose Registers (R0-R63)
	  ("SCR-OFFSET"  #x100) ;; Special Core Registers (CONFIG, STATUS...)
	  ("DMA-OFFSET"  #x140) ;; DMA Registers
	  ("MEM-OFFSET"  #x180) ;; Mem protection registers
	  ("MESH-OFFSET" #x1c0) ;; Mesh Config registers
	)
  )
)

(define-enum
  (name e-scr-set-mask)
  (comment "mask for sticky bits in special core registers")
  ;;(attrs)
  (prefix H-SCR-MASK-)
  (values
    (
	  ("STATUS"   #xfff0)
	)
  )
)


; General Register keyword names.
(define-keyword
  (name gr-names)
  (enum-prefix H-GPR-REGS-)
  (name-prefix "")
  (values
; some preferred aliases
   (ip 12) (sp 13) (lr 14) (fp 15)
; the default register names
   (r0  0)  (r1  1)  (r2  2)  (r3  3)  (r4  4)  (r5  5)  (r6  6)  (r7  7)
   (r8  8)  (r9  9) (r10 10) (r11 11) (r12 12) (r13 13) (r14 14) (r15 15)
   (r16 16) (r17 17) (r18 18) (r19 19) (r20 20) (r21 21) (r22 22) (r23 23)
   (r24 24) (r25 25) (r26 26) (r27 27) (r28 28) (r29 29) (r30 30) (r31 31)
   (r32 32) (r33 33) (r34 34) (r35 35) (r36 36) (r37 37) (r38 38) (r39 39)
   (r40 40) (r41 41) (r42 42) (r43 43) (r44 44) (r45 45) (r46 46) (r47 47)
   (r48 48) (r49 49) (r50 50) (r51 51) (r52 52) (r53 53) (r54 54) (r55 55)
   (r56 56) (r57 57) (r58 58) (r59 59) (r60 60) (r61 61) (r62 62) (r63 63)
; some less popular aliases
   (a1  0) (a2  1) (a3  2) (a4  3) (v1  4) (v2  5) (v3  6) (v4  7)
   (v5  8) (v6  9) (v7 10) (v8 11)
   (sb 9) (sl 10)
   )
  )

(define-normal-insn-enum post-index "+/- index register" () DIR_ f-addsubx (POSTINC POSTDEC))

(define-normal-insn-enum disp-post-modify "postmodify displacement" () PMOD_ f-pm (DISP POST))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Hardware pieces.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; All registers
;; All other registers are virtual.
;; Everything is routed through here to keep things in one place
;;
(define-hardware
  (name h-all-registers)
  (comment "all addressable registers")
  (type register USI (512))
  (indices extern-keyword all-reg-names)
  (attrs PROFILE)
  ;; Might want add mem barriers for set/get here.
  (set (index val)
    (cond VOID
      ((eq index (enum USI H-REG-SCR-CONFIG))
        (c-call "epiphanybf_set_config" val)
      )
      ((eq index (enum USI H-REG-SCR-STATUS))
        (c-call "epiphanybf_set_status" val (const 0))
      )
      ((eq index (enum USI H-REG-SCR-FSTATUS))
        (c-call "epiphanybf_set_status" val (const 1))
      )
      ((eq index (enum USI H-REG-SCR-IMASK))
        (c-call "epiphanybf_set_imask" val)
      )
      ((eq index (enum USI H-REG-SCR-ILATST))
        (c-call "epiphanybf_set_ilatst" val)
      )
      ((eq index (enum USI H-REG-SCR-ILATCL))
        (c-call "epiphanybf_set_ilatcl" val)
      )
      ((eq index (enum USI H-REG-MESH-RESETCORE))
        (c-call "epiphanybf_set_resetcore" val)
      )
      ((and (ge index (enum H-REG-DMA0-CONFIG))
            (le index (enum H-REG-DMA1-STATUS)))
        (c-call "epiphanybf_set_dmareg" index val)
      )
      ((eq index (enum USI H-REG-SCR-SIMCMD))
        (c-call "epiphanybf_set_simcmd" val)
      )
      ((eq index (enum USI H-REG-MESH-COREID))
        ;; coreid is read-only. make operation no-op
        (set (raw-reg h-all-registers (enum USI H-REG-MESH-COREID))
             (reg h-all-registers (enum USI H-REG-MESH-COREID)))
      )
      (else (set (raw-reg h-all-registers index) val))
    )
  )
)


;; 64 general-purpose registers
(define-hardware
  (name h-registers)
  (comment "General Purpose Registers")
  (type register USI (64))
  (attrs PROFILE VIRTUAL)
  (indices extern-keyword gr-names)
  ;; Forward get/set to h-all-registers handlers
  ;; Offset to GPR is 0 so we don't need to add anything to index.
  (get (index) (reg h-all-registers index))
  (set (index newval) (set (reg h-all-registers index) newval))
)

;; Same 64 registers as dword registers
;; TODO: ??? Do in C to avoid race conditions.
;; TODO: Throw exception if unaligned?
(define-hardware
  (name h-registers-di)
  (comment "all GPRs as DWORDs")
  (type register DI (64))
  (attrs PROFILE VIRTUAL)
  (indices extern-keyword gr-names)
  ;; Forward get/set to h-all-registers handlers
  ;; Offset to GPR is 0 so we don't need to add anything to index.
  (get (index) (join DI SI (reg h-all-registers (add UINT index 1))
                           (reg h-all-registers index)))
  (set (index newval) (sequence ()
      (set (reg h-all-registers index) (subword SI newval 1))
      (set (reg h-all-registers (add USI index 1)) (subword SI newval 0)))
  )
)

(define-enum
  (name e-scr-status-bits)
  (comment "core status bits")
  ;;(attrs) -- epiphany-3,4,5
  (prefix H-SCR-STATUS-)
  (values
    (
	  ("CAIBIT"         0)
	  ("GIDISABLEBIT"   1)
	  ("KMBIT"          2) ;; UNDOCUMENTED/RESERVED
	  ("SFLAGBIT"       3) ;; UNDOCUMENTED/RESERVED
	  ("ZBIT"           4)
	  ("NBIT"           5)
	  ("CBIT"           6)
	  ("VBIT"           7)
	  ("BZBIT"          8)
	  ("BNBIT"          9)
	  ("BVBIT"         10)
	  ("BCBIT"         11) ;; UNDOCUMENTED/RESERVED
	  ("VSBIT"         12)
	  ("BISBIT"        13)
	  ("BVSBIT"        14)
	  ("BUSBIT"        15)
	  ("EXCAUSE0BIT"   16)
	  ("EXCAUSE1BIT"   17)
	  ("EXCAUSE2BIT"   18)
	  ("EXCAUSE3BIT"   19) ;; UNDOCUMENTED/RESERVED
	  ("BIT20"         20) ;; UNDOCUMENTED/RESERVED
	  ("BIT21"         21) ;; UNDOCUMENTED/RESERVED
	  ("BIT22"         22) ;; UNDOCUMENTED/RESERVED
	  ("BIT23"         23) ;; UNDOCUMENTED/RESERVED
	  ("BIT24"         24) ;; UNDOCUMENTED/RESERVED
	  ("BIT25"         25) ;; UNDOCUMENTED/RESERVED
	  ("BIT26"         26) ;; UNDOCUMENTED/RESERVED
	  ("BIT27"         27) ;; UNDOCUMENTED/RESERVED
	  ("BIT28"         28) ;; UNDOCUMENTED/RESERVED
	  ("BIT29"         29) ;; UNDOCUMENTED/RESERVED
	  ("BIT30"         30) ;; UNDOCUMENTED/RESERVED
	  ("BIT31"         31) ;; UNDOCUMENTED/RESERVED
	)
  )
)

;; Exception cause bits, different for Epiphany-III and Epiphany-IV
;; Use the Epiphany-III values for now.
;; TODO: Have separate machs for Epiphany-III and Epiphany-IV
;(define-enum
;  (name e-excause)
;  (comment "Epiphany-III exception cause")
;  (prefix H-SCR-STATUS-EXCAUSE-)
;  ;;(attrs (MACH epiphanymf-3))
;  (values
;	(
;	  ("UNIMPLEMENTED" 4)
;	  ("SWI"           1)
;	  ("UNALIGNED"     2)
;	  ("ILLEGAL"       5)
;	  ("FPU"           3)
;	)
;  )
;)

;; Epiphany-IV exception causes
(define-enum
  (name e-excause)
  (comment "Epiphany-IV exception cause")
  (prefix H-SCR-STATUS-EXCAUSE-)
  ;;(attrs (MACH epiphanymf-4))
  (values
	(
	  ("UNIMPLEMENTED" 15)
	  ("SWI"           14)
	  ("UNALIGNED"     13)
	  ("ILLEGAL"       12)
	  ("FPU"            7)
	)
  )
)

(define-enum
  (name e-scr-config-bits)
  (comment "core config bits")
  ;;(attrs)
  (prefix H-SCR-CONFIG-)
  (values
    (
	  ("TRMBIT"               0)
	  ("INVEXCENBIT"          1)
	  ("OVFEXCENBIT"          2)
	  ("UNEXCENBIT"           3)
	  ("TIMER0BIT0"           4)
	  ("TIMER0BIT1"           5)
	  ("TIMER0BIT2"           6)
	  ("TIMER0BIT3"           7)
	  ("TIMER1BIT0"           8)
	  ("TIMER1BIT1"           9)
	  ("TIMER1BIT2"          10)
	  ("TIMER1BIT3"          11)
	  ("MESHROUTEBIT0"       12) ;; UNDOCUMENTED/RESERVED
	  ("MESHROUTEBIT1"       13) ;; UNDOCUMENTED/RESERVED
	  ("MESHROUTEBIT3"       14) ;; UNDOCUMENTED/RESERVED
	  ("MESHROUTEBIT4"       15) ;; UNDOCUMENTED/RESERVED
	  ("SPLITBIT"            16) ;; UNDOCUMENTED/RESERVED
	  ("ARITH-MODEBIT0"      17)
	  ("ARITH-MODEBIT1"      18)
	  ("ARITH-MODEBIT2"      19)
	  ("EMULMODEBIT"         20) ;; UNDOCUMENTED/RESERVED
	  ("SINGLEISSUEBIT"      21) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKGATEENBIT"      22)
	  ("MBKPTENBIT"          23)
	  ("CORECONFIGBIT24"     24)
	  ("CORECONFIGBIT25"     25)
	  ("CORECONFIGBIT26"     26)
	  ("CORECONFIGBIT27"     27)
	  ("CLOCKDIVBIT0"        28) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKDIVBIT1"        29) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKDIVBIT2"        30) ;; UNDOCUMENTED/RESERVED
	  ("CLOCKDIVBIT3"        31) ;; UNDOCUMENTED/RESERVED
	)
  )
)

(define-enum
  (name e4-scr-config-bits)
  (comment "Epiphany-4 config bits")
  ;;(attrs) -- epiphany-4 epiphany-5
  (prefix H-SCR-CONFIG-)
  (values
    (
     (TIMERWRAP 26)
    )
  )
)

(define-enum
  (name e5-scr-config-bits)
  (comment "Epiphany-5 config bits")
  ;;(attrs) -- epiphany-5
  (prefix H-SCR-CONFIG-)
  (values
    (
     (64BMODE 21)
    )
  )
)

(define-enum
  (name e-interrupts)
  (comment "Epiphany interrupt numbers")
  ;;(attrs) -- epiphany-5
  (prefix H-INTERRUPT-)
  (values (SYNC EXCEPTION MEMFAULT TIMER0 TIMER1 MESSAGE DMA0 DMA1 WAND SWI MAX))
)

(define-enum
  (name e-dma-config-bits)
  (comment "dma config bits")
  ;;(attrs)
  (prefix H-DMA-CONFIG-)
  (values
    (
	  (ENABLEBIT        0)
	  (MASTERBIT        1)
	  (CHAINMODEBIT     2)
	  (STARTUPBIT       3)
	  (IRQENBIT         4)
	  (DATASIZEBIT0     5)
	  (DATASIZEBIT1     6)
	  ;; [15:7]  reserved
	  ;; [31:16] next dma descriptor pointer
	)
  )
)

(define-enum
  (name e-dma-status-bits)
  (comment "dma status bits")
  ;;(attrs)
  (prefix H-DMA-STATUS-)
  (values
    (
	  (DMASTATEBIT0        0)
	  (DMASTATEBIT1        1)
	  (DMASTATEBIT2        2)
	  (DMASTATEBIT3        3)
	  ;; [15:4]  reserved
	  ;; [31:16] current dma descriptor pointer
	)
  )
)

;; Special registers - accessed via MOVTS and MOVFS.
;;
;;  "Core control and status" in group MR0=0, MR1=0

(define-keyword
  (name cr-names)
  (enum-prefix H-CORE-REGISTERS-)
  (name-prefix "")
  (values
	(config       0)
	(status       1) ; unified condition codes
	(pc           2) ; virtualized PC
	(debug        3) ; debugstatus
	(iab          4)
	(lc           5) ;loop counter            Not impemented
	(ls           6) ;loop start address      Not impemented
	(le           7) ;loop end address        Not impemented
	(iret         8)
	(imask        9)
	(ilat        10)
	(ilatst      11)
	(ilatcl      12)
	(ipend       13)
	(ctimer0     14)
	(ctimer1     15)
	(fstatus     16)
  )
)
;; DMA registers in group MR0=1, MR1=0

(define-keyword
  (name crdma-names)
  (enum-prefix H-COREDMA-REGISTERS-)
  (name-prefix "")
  (values
	(dma0config     0)
	(dma0stride     1)
	(dma0count      2)

	(dma0srcaddr    3)
	(dma0dstaddr    4)

	(dma0auto0      5)
	(dma0auto1      6)

	(dma0status     7)

	(dma1config     8)
	(dma1stride     9)
	(dma1count      10)

	(dma1srcaddr    11)
	(dma1dstaddr    12)

	(dma1auto0      13)
	(dma1auto1      14)

	(dma1status     15)
  )
)
;; mem configuration registers in group MR0=0, MR1=1

(define-keyword
  (name crmem-names)
  (enum-prefix H-COREMEM-REGISTERS-)
  (name-prefix "")
  (values
	(memconfig     0)
	(memstatus     1)
	(memprotect    2)
	(memreserve    3)
  )
)

;; mesh configuration registers in group MR0=1, MR1=1

(define-keyword
  (name crmesh-names)
  (enum-prefix H-COREMESH-REGISTERS-)
  (name-prefix "")
  (values
	(meshconfig    0)
	(coreid        1)
	(meshmulticast 2)
	(resetcore     3)
  )
)


;; call exception macro - no check for imask
(define-pmacro (schedule-exception reason)
  (sequence ()
	(set (reg h-scr-status-excause) reason) ;; STATUS bits alias.
	(set (reg h-all-registers (enum UINT H-REG-SCR-ILATST)) 2) ;; Exception interrupt bit
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; PC is a byte-addressed register
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define-hardware
  (name h-hwloop-next)
  ;; Set to true means that we should jump to ls after this instruction
  (type register BI)
)

(define-hardware
  (name h-pc)
  (comment "program counter")
  (type pc)
  (attrs PC PROFILE VIRTUAL)
  ;; Forward get/set to h-all-registers handlers
  (get () (reg h-all-registers (enum USI H-REG-SCR-PC)))
  (set (newpc)
    (if (eq (const 0) (c-call BI "epiphanybf_fetchable_p" newpc))
      (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-ILLEGAL))
      (if (eq (reg h-all-registers (enum USI H-REG-SCR-LC)) 0)
	(set (reg h-all-registers (enum USI H-REG-SCR-PC)) newpc)
	(if (reg h-hwloop-next)
	  (sequence ((USI lc))
	    (set-quiet (reg h-hwloop-next) 0)
	    (set (reg h-all-registers (enum USI H-REG-SCR-PC))
		 (reg h-all-registers (enum USI H-REG-SCR-LS)))
	    (set lc (reg h-all-registers (enum USI H-REG-SCR-LC)))
	    (set (reg h-all-registers (enum USI H-REG-SCR-LC)) (sub lc 1))
	  )
	  (sequence ((USI lc) (USI ls) (USI le) (USI corebase) (USI globpc))
	    (set corebase
		 (sll (reg h-all-registers (enum USI H-REG-MESH-COREID)) 20))

	    (set lc (reg h-all-registers (enum USI H-REG-SCR-LC)))

	    (set ls (reg h-all-registers (enum USI H-REG-SCR-LS)))
	    (if (lt ls #x100000) (set ls (or ls corebase)))
	    (set le (reg h-all-registers (enum USI H-REG-SCR-LE)))
	    (if (lt le #x100000) (set le (or le corebase)))

	    (if (lt newpc #x100000)
	      (set globpc (or newpc corebase))
	      (set globpc newpc)
	    )

	    (if (eq globpc ls)
	      (set (reg h-all-registers (enum USI H-REG-SCR-LC)) (sub lc 1))
	    )
	    (if (eq globpc le)
	      ;; ???: TODO: Throw unaligned exception if (addr % 8 != 0)
	      (set-quiet (reg h-hwloop-next) 1)
	    )
	    (set (reg h-all-registers (enum USI H-REG-SCR-PC)) newpc)
	  )
	)
      )
    )
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     ; Memory Effective Address wants to be visible for tracing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dnh h-memaddr "memory effective address" (PROFILE) (register DI) () () ())
(dnop memaddr  "memory effective address" (SEM-ONLY) h-memaddr f-nil)

;; For tracing atomic memory operations
(dnh h-memory-atomic "atomic memory access" (PROFILE) (register DI) () () ())
(dnh h-memory-atomic-flag "atomic memory access flag" () (register BI) () () ())
(dnop memory-atomic  "atomic memory access" (SEM-ONLY) h-memory-atomic f-nil)
(dnop memory-atomic-flag  "atomic memory access flag" (SEM-ONLY) h-memory-atomic-flag f-nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Special Core Registers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; STATUS
;; [0]=core active indicator
;; [1]=global interrupt disable
;; [2]=processor mode(1=user mode, 0=kernel mode)
;; [3]=wired AND global flag

;; [4]=integer zero                        zbit
;; [5]=integer negative                    nbit
;; [6]=integer carry                       cbit
;; [7]=integer overflow                    vbit

;; [8]=fpu zero flag                       bzbit
;; [9]=fpu negative flag                   bnbit
;; [10]=fpu overflow flag                  bvbit
;; [11]=fpu carry flag(not used)           bcbit

;; [12]=ialu overflow flag(sticky)         vsbit
;; [13]=fpu invalid flag(sticky)           bisbit
;; [14]=fpu overflow flag(sticky)          bvsbit
;; [15]=fpu underflow flag(sticky)         busbit

;; [17:16]=exception cause 00=no exception 01=load-store exception 10=fpu exception 11=unimplemented instruction
;;                                         excause1bit
;;                                         excause0bit

;; [18]=external load stalled              excause2bit
;; [19]=external fetch stalled             extFstallbit

;; [31:20]=RESERVED





(define-hardware
  (name h-core-registers)
  (comment "Special Core Registers")
  (type register USI (17))
  (attrs VIRTUAL)
  (indices extern-keyword cr-names)
  ;; Forward get/set to h-all-registers handlers
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-SCR-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-SCR-OFFSET) index))
		  val)
  )
)
					; (define-pmacro (hcr-config) (reg h-core-registers 0)) etc.
(%splice begin (%unsplice (%map
			   (%pmacro (xname xnum)
				    ;;(define-pmacro ((%sym hcr- xname)) (reg h-core-registers xnum)))
					;;(dnop name cmt (SEM-ONLY) hname f-nil)
				    (define-pmacro ((%sym hcr- xname)) (reg h-core-registers xnum)))

			   (
			    config
			    status
			    pc
			    debug ;; debugstatus
			    iab
			    lc
			    ls
			    le
			    iret
			    imask
			    ilat
			    ilatst
			    ilatcl
			    ipend
			    ctimer0
			    ctimer1
			    hstatus



			    )

			   (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
			      )
			   )))

; Define hardware and operands for each of the physical bits in STATUS &
; CONFIG registers
(define-pmacro (psw-bit Name Cmt Regidx Prefix)
  (%let (
	  (h-name (%sym "h-" Name))
	  (bitidx    (%sym (%upcase (%str Prefix Name))))
	  (operand (reg h-all-registers Regidx))
    )
    (begin
	  (define-hardware
		(name h-name)
		(comment Cmt)
		(attrs VIRTUAL)
		(type register BI)
		(get ()
		  (
			sequence ((SI regval) (SI bitval))
			  (set regval operand)
			  (set bitval (and (srl regval bitidx) 1))
			  (trunc BI bitval)
		  )
		)
		(set (newval)
		  ;; Set reg bit without interfering with other bits
		  (c-raw-call VOID "SET_REG_BIT_ATOMIC" Regidx (enum USI bitidx) newval)
		)
	  )
	  (dnop Name cmt (SEM-ONLY) h-name f-nil)
	)
  )
)

(define-pmacro (psw-bit-cr-status Name Cmt)
  (psw-bit Name Cmt (enum H-REG-SCR-STATUS) H-SCR-STATUS-)
)
(define-pmacro (psw-bit-cr-config Name Cmt)
  (psw-bit Name Cmt (enum H-REG-SCR-CONFIG) H-SCR-CONFIG-)
)
;; Operands for status bits
(psw-bit-cr-status caibit       "core active indicator mode bit" ) ;;  0
(psw-bit-cr-status gidisablebit "global interrupt disable bit"   ) ;;  1
(psw-bit-cr-status kmbit        "kernel mode bit"                ) ;;  2
(psw-bit-cr-status sflagbit     "sflag bit"                      ) ;;  3
(psw-bit-cr-status zbit         "integer zero bit"               ) ;;  4
(psw-bit-cr-status nbit         "integer neg bit"                ) ;;  5
(psw-bit-cr-status cbit         "integer carry bit"              ) ;;  6
(psw-bit-cr-status vbit         "integer overflow bit"           ) ;;  7
(psw-bit-cr-status bzbit        "floating point zero bit"        ) ;;  8
(psw-bit-cr-status bnbit        "floating point neg bit"         ) ;;  9
(psw-bit-cr-status bvbit        "floating point ovfl bit"        ) ;; 10
(psw-bit-cr-status bcbit        "floating point carry bit"       ) ;; 11
(psw-bit-cr-status vsbit        "integer overflow sticky"        ) ;; 12
(psw-bit-cr-status bisbit       "floating point invalid sticky"  ) ;; 13
(psw-bit-cr-status bvsbit       "floating point overflow sticky" ) ;; 14
(psw-bit-cr-status busbit       "floating point underflow sticky") ;; 15
(psw-bit-cr-status excause0bit  "exception cause bit0"           ) ;; 16
(psw-bit-cr-status excause1bit  "exception cause bit1"           ) ;; 17
(psw-bit-cr-status excause2bit  "exception cause bit2"           ) ;; 18
(psw-bit-cr-status excause3bit  "exception cause bit3"           ) ;; 19

;; Excause operand
(define-hardware
  (name h-scr-status-excause)
  (comment "Exception cause bits in status register")
  (type register UQI) ;; Not really, just 4 bits
  (attrs VIRTUAL)
  ;; Forward get/set to h-all-registers handlers
  (get ()
	(sequence ((SI status))
	   (set status (reg h-all-registers (enum SI H-REG-SCR-STATUS)))
	   (and (srl status H-SCR-STATUS-EXCAUSE0BIT) #xf)
	)
  )
  ;; Two steps: clear bits, then set value
  (set (newval)
	(sequence ((SI mask) (SI shifted))
	  (set mask #xfff0ffff)  ;; bit 16-19
	  (set shifted (sll (and newval #xf) (enum USI H-SCR-STATUS-EXCAUSE0BIT)))
	  (c-raw-call VOID "AND_REG_ATOMIC"  (enum USI H-REG-SCR-STATUS) mask)
	  (c-raw-call VOID "OR_REG_ATOMIC"   (enum USI H-REG-SCR-STATUS) shifted)
	)
  )
)

;; Operands for config bits
(psw-bit-cr-config trmbit              "0=round to nearest, 1=truncate select bit")
(psw-bit-cr-config invexcenbit         "invalid exception enable bit"   )
(psw-bit-cr-config ovfexcenbit         "overflow exception enable bit"  )
(psw-bit-cr-config unexcenbit          "underflow exception enablebit"  )

(psw-bit-cr-config timer0bit0          "timer 0 mode selection 0"       )
(psw-bit-cr-config timer0bit1          "timer 0 mode selection 1"       )
(psw-bit-cr-config timer0bit2          "timer 0 mode selection 2"       )
(psw-bit-cr-config timer0bit3          "timer 0 mode selection 3"       )
(psw-bit-cr-config timer1bit0          "timer 1 mode selection 0"       )
(psw-bit-cr-config timer1bit1          "timer 1 mode selection 1"       )
(psw-bit-cr-config timer1bit2          "timer 1 mode selection 2"       )
(psw-bit-cr-config timer1bit3          "timer 1 mode selection 3"       )

(psw-bit-cr-config arith-modebit0      "arithmetic mode bit0"           )
(psw-bit-cr-config arith-modebit1      "arithmetic mode bit1"           )
(psw-bit-cr-config arith-modebit2      "arithmetic mode bit2"           )

(psw-bit-cr-config clockgateenbit      "clock gating enable bkpt enable")
(psw-bit-cr-config mbkptenbit          "multicore bkpt enable"          )


;; arithmode hardware
(define-hardware
  (name h-scr-config-arithmode)
  (comment "Arithmetic mode")
  (type register QI) ;; Not really, just 4 bits
  (attrs VIRTUAL)
  ;; Forward get/set to h-all-registers handlers
  (get ()
    (sequence ((SI mode))
       (set mode (reg h-all-registers (enum USI H-REG-SCR-CONFIG)))
       (and (srl mode H-SCR-CONFIG-ARITH-MODEBIT0) #xf)
    )
  )
  ;; Two steps: clear bits, then set value
  (set (newval)
    (sequence ((USI mask) (USI shifted))
      (set mask #xffe1ffff)  ;; bit 17-20
      (set shifted (sll (and newval #xf)
                        (enum UINT H-SCR-CONFIG-ARITH-MODEBIT0)))
      (c-raw-call VOID "AND_REG_ATOMIC"  (enum UINT H-REG-SCR-CONFIG) mask)
      (c-raw-call VOID "OR_REG_ATOMIC"   (enum UINT H-REG-SCR-CONFIG) shifted)
    )
  )
)
(define-enum
  (name e-arithmode)
  (comment "arithmetic mode")
  ;;(attrs)
  (prefix ARITHMODE-)
  (values
    (
      ("SF"      0) ;; single float
      ("DF"      1) ;; double float
      ("SI"      4) ;; single integer
      ("SF-SIMD" 8) ;; single float SIMD mode
    )
  )
)
(dnop
  arithmode
  "arithmetic mode operand"
  (SEM-ONLY)
  h-scr-config-arithmode
  f-nil
)

;; DMA registers in MMR space
(define-hardware
  (name h-coredma-registers)
  (comment "DMA registers in MMR space")
  (type register USI (16))
  (attrs VIRTUAL)
  (indices extern-keyword crdma-names)
  ;; Forward get/set to h-all-registers handlers
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-DMA-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-DMA-OFFSET) index))
		  val)
  )
)

;; MEM registers in MMR space
(define-hardware
  (name h-coremem-registers)
  (comment "MEM registers in MMR space")
  (type register USI (4))
  (attrs VIRTUAL) ;; ?? PROFILE ??
  (indices extern-keyword crmem-names)
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-MEM-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-MEM-OFFSET) index))
		  val)
  )
)

;; MEM registers in MMR space
(define-hardware
  (name h-coremesh-registers)
  (comment "MESH registers in MMR space")
  (type register USI (4))
  (attrs VIRTUAL) ;; ?PROFILE?
  (indices extern-keyword crmesh-names)
  (get (index)
	(reg h-all-registers (add USI (enum USI H-REG-GRP-MESH-OFFSET) index))
  )
  (set (index val)
	(set (reg h-all-registers (add USI (enum USI H-REG-GRP-MESH-OFFSET) index))
		  val)
  )
)

					; Operands

					; Branch displacements
(define-operand
  (name simm24)
  (comment "branch address pc-relative")
  (attrs RELAX)
  (type h-iaddr)
  (index f-simm24)
  (handlers (parse "branch_addr")))

(define-operand
  (name simm8)
  (comment "branch address pc-relative")
  (attrs RELAX)
  (type h-iaddr)
  (index f-simm8)
  (handlers (parse "branch_addr")))

(define-operand
  (name pos-direction)
  (comment "positive direction")
  (attrs)
  (type h-uint)
  (index f-nil)
  (handlers (parse "pos_direction") (print "pos_direction")))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					; Register operands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (short-regs nm group hw cmt)
  (define-operand
    (name nm)
    (comment cmt)
    (attrs)
    (type hw)
    (index (%sym "f-r" group))
    (handlers (parse "shortregs") (print "keyword"))
    )
  )

(define-pmacro (short-regs-core nm group hw cmt)
  (define-operand
    (name nm)
    (comment cmt)
    (attrs)
    (type hw)
    (index (%sym "f-s" group))
    (handlers (parse "shortregs") (print "keyword"))
    )
  )


					; short regs (0-7)
(short-regs rd d h-registers "destination register")
(short-regs rn n h-registers "source register")
(short-regs rm m h-registers "source register")

; double-word shortreg
(define-pmacro (dnop-short-dword-reg xname xindex xcomment)
  (define-operand
    (name xname)
    (comment xcomment)
    (attrs)
    (type h-registers-di)
    (index xindex)
    (handlers (parse "dword_shortregs") (print "keyword"))
  )
)
(dnop-short-dword-reg rd-di f-rd "dword destination register")
(dnop-short-dword-reg rn-di f-rn "dword source register")
(dnop-short-dword-reg rm-di f-rm "dword source register")

					; long regs (0-63)
(dnop rd6 "destination register" () h-registers f-rd6)
(dnop rn6 "source register"      () h-registers f-rn6)
(dnop rm6 "source register"      () h-registers f-rm6)

; 64-bit versions of general purpose regs
(define-pmacro (dnop-dword-reg xname xindex xhardware xcomment)
  (define-operand
    (name xname)
    (comment xcomment)
    (attrs) ;; TODO: MACH Epiphany-5
    (type xhardware)
    (index xindex)
    (handlers (parse "dword_regs") (print "keyword"))
  )
)
(dnop-dword-reg rd6-di f-rd6 h-registers-di "destination register")
(dnop-dword-reg rn6-di f-rn6 h-registers-di "source register")
(dnop-dword-reg rm6-di f-rm6 h-registers-di "source register")

					; special regs (0-7)
(short-regs-core sd d h-core-registers "special destination")
(short-regs-core sn n h-core-registers "special source")

					; special regs (long form)
(dnop sd6 "special destination register" () h-core-registers f-sd6)
(dnop sn6 "special source register"      () h-core-registers f-sn6)

(dnop sddma "dma register" () h-coredma-registers f-sd6)
(dnop sndma "dma register"      () h-coredma-registers f-sn6)
(dnop sdmem "mem register" () h-coremem-registers f-sd6)
(dnop snmem "mem register"      () h-coremem-registers f-sn6)
(dnop sdmesh "mesh register" () h-coremesh-registers f-sd6)
(dnop snmesh "mesh register"      () h-coremesh-registers f-sn6)

					; Immediate literals - but don't allow register names!
(define-pmacro (dimmop nm cmt hwtype idx)
  (define-operand (name nm) (comment cmt) (type hwtype) (index idx)
    (attrs RELAX)
    (handlers (parse "simm_not_reg")
	      (print "simm_not_reg")))
  )

(dimmop simm3   "signed 3-bit literal"    h-sint f-sdisp3)
(dimmop simm11  "signed 11-bit literal"   h-sint f-sdisp11)
(dnop disp3  "short data displacement"   () h-uint f-disp3)
(dnop trapnum6 "parameter for swi or trap" () h-uint f-trap-num)

(define-pmacro (duimmop nm cmt hwtype idx)
  (define-operand (name nm) (comment cmt) (type hwtype) (index idx)
    (attrs)
    (handlers (parse "uimm_not_reg")
	      (print "uimm_not_reg")))
  )

(duimmop swi_num "unsigned 6-bit swi#" h-uint f-trap-num)
(duimmop disp11 "sign-magnitude data displacement" h-uint f-disp11)

(dnop shift   "immediate shift amount"   () h-uint f-shift)

(define-operand (name imm16) (comment "16-bit unsigned literal") (attrs RELAX)
  (type h-addr) (index f-imm16) (handlers (parse "imm16")))
(define-operand (name imm8) (comment "8-bit unsigned literal") (attrs RELAX)
  (type h-addr) (index f-imm8) (handlers (parse "imm8")))

(dnop mode4 "4-bit unsigned literal"      () h-uint f-mode4)
(dnop ctrlmode5 "atomic #imm5 ctrlmode"    () h-uint f-ctrlmode5)

(define-operand
  (name direction)
  (comment "+/- indexing")
  (attrs)
  (type h-uint)
  (index f-addsubx)
  (handlers (parse "postindex")
	    (print "postindex")))

(define-operand
  (name dpmi)
  (comment "+/- magnitude immediate displacement")
  (attrs)
  (type h-uint)
  (index f-subd)
  (handlers (parse "postindex")
	    (print "postindex")))



;; Some handy macros
;;

;; define instructions
;;   Short (16 bit forms) must appear first so that instruction
;;   selection can reject them and match long forms when registers
;;   or immediates exceed the values in the 16 bit instructions


;; B<COND> SIMM8
;; B<COND> SIMM24

(define-pmacro (br-insn name cond g-op)
  (begin
					; the 16-bit versions of branch
    (dni (%sym "b" name "16")
	 (%str "Conditional Branch - 16 bit" name)
	 (COND-CTI SHORT-INSN)
	 (%str "b" name ".s $simm8")
	 (+ OP4_BRANCH16 (%sym "OPC_" cond) simm8)
	 (if (g-op)
	     (set pc simm8)
	     )
	 ()
	 )

    (dnmi (%sym "b" name "16r") "relaxable conditional branch"
	  (COND-CTI RELAXABLE)
	  (%str "b" name " $simm8")
	  (emit (%sym "b" name "16") simm8)
	  )

    (dni (%sym "b" name)
	 (%str "Conditional Branch " name)
	 (COND-CTI)
	 (%str "b" name ".l $simm24")
	 (+ OP4_BRANCH (%sym "OPC_" cond) simm24)
	 (if (g-op)
	     (set pc simm24)
	     )
	 ()
	 )

    (dnmi (%sym "b" name "32r") "relaxable conditional branch"
	  (COND-CTI RELAXED)
	  (%str "b" name " $simm24")
	  (emit (%sym "b" name) simm24)
	  )
    )
  )


					; basic conditional branches for integer arithmetic
(br-insn "eq"	 EQ	(%pmacro () (eq zbit #x1)))
(br-insn "ne"	 NE	(%pmacro () (eq zbit #x0)))
(br-insn "gtu"   GTU	(%pmacro () (and BI cbit (not BI zbit))))
(br-insn "gteu"  GTEU	(%pmacro () (eq cbit #x1)))
(br-insn "lteu"  LTEU	(%pmacro () (or BI (not BI cbit) zbit)))
(br-insn "ltu"   LTU	(%pmacro () (eq cbit #x0)))
(br-insn "gt"	 GT	(%pmacro () (and BI (not BI zbit) (eq vbit nbit))))
(br-insn "gte"   GTE	(%pmacro () (eq vbit nbit)))
(br-insn "lt"	 LT	(%pmacro () (xor BI vbit nbit)))
(br-insn "lte"   LTE	(%pmacro () (or BI zbit (xor vbit nbit))))


					; floating point condition codes (floating point instructions)
(br-insn "beq"   BEQ    (%pmacro () (or BI bzbit bzbit)))
(br-insn "bne"   BNE    (%pmacro () (not BI bzbit)))
(br-insn "blt"   BLT    (%pmacro () (and BI bnbit (not bzbit))))
(br-insn "blte"  BLTE   (%pmacro () (or BI bnbit bzbit)))

					; unconditional branches
(dni b16 "short unconditional branch" (UNCOND-CTI SHORT-INSN)
     "b.s $simm8"
     (+ OP4_BRANCH16 OPC_B simm8)
     (set pc simm8)
     ()
     )

(dnmi b16r "relaxable b16"
      (UNCOND-CTI RELAXABLE)
      "b $simm8"
      (emit b16 simm8)
      )

(dni b "long unconditional branch" (UNCOND-CTI)
     "b.l $simm24"
     (+ OP4_BRANCH OPC_B simm24)
     (set pc simm24)
     ()
     )

(dnmi b32r "relaxable b"
      (UNCOND-CTI RELAXED)
      "b $simm24"
      (emit b simm24))

;; BL R,ADDR

(dni bl16 "branch and link"
     (UNCOND-CTI SHORT-INSN)
     ("bl.s $simm8")
     (+ OP4_BRANCH16 OPC_BL simm8)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 2)))
	       (set pc simm8))
     ()
     )

(dnmi bl16r "bl16 relaxable"
      (UNCOND-CTI RELAXABLE)
      "bl $simm8"
      (emit bl16 simm8))

(dni bl "branch and link"
     (UNCOND-CTI)
     ("bl.l $simm24")
     (+ OP4_BRANCH OPC_BL simm24)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 4)))
	       (set pc simm24))
     ()
     )

(dnmi blr "bl relaxable"
      (UNCOND-CTI RELAXED)
      "bl $simm24"
      (emit bl simm24))

;; JUMP <RN>
(dni jr16 "unconditional jump 16"
     (UNCOND-CTI SHORT-INSN)
     ("jr $rn")
     (+ OP4_FLOW16 (f-opc-8-5 #x14) (f-dc-15-3 #x0) (f-dc-9-1 #x0) rn)
     (set pc rn)
     ()
     )

;; RTS / JR
;; ??? Putting a constant into a multi-ifield does not work -
;; the constant gets inserted in full into each part.
					;(dnmi rts "return from subroutine"
					;     (UNCOND-CTI)
					;     ("rts")
					;     (emit jr (rn6 14)) ; jr lr  / jr r14
					;)
;; RTS / JR
(dni rts "return from subroutine"
     (ALIAS UNCOND-CTI)
     ("rts")
     (+ OP4_MISC (f-opc-8-5 #x14) (f-opc-19-4 #x2) (f-rn 6) (f-rn-x 1)
	(f-dc-9-1 #x0)
	(f-dc-15-3 #x0)
	(f-dc-25-6 #x0)
	(f-dc-31-3 #x0)
	)
     (set pc (reg h-registers 14))
     ()
     )

(dni jr "unconditional jump"
     (UNCOND-CTI)
     ("jr $rn6")
     (+ OP4_MISC (f-opc-8-5 #x14) (f-opc-19-4 #x2) rn6
	(f-dc-9-1 #x0)
	(f-dc-15-3 #x0)
	(f-dc-25-6 #x0)
	(f-dc-31-3 #x0)
	)
     (set pc rn6)
     ()
     )


;; JALR <RN>
(dni jalr16 "jump and link register"
     (UNCOND-CTI SHORT-INSN)
     ("jalr $rn")
     (+ OP4_FLOW16  (f-opc-8-5 #x15) (f-dc-15-3 #x0) (f-dc-9-1 #x0)  rn)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 2)))
	       (set pc rn)
	       )
     ()
     )

(dni jalr "jump and link register"
     (UNCOND-CTI)
     ("jalr $rn6")
     (+ OP4_MISC
	(f-opc-8-5 #x15)
	(f-opc-19-4 #x2)
	rn6
	(f-dc-9-1 #x0)
	(f-dc-15-3 #x0)
	(f-dc-25-6 #x0)
	(f-dc-31-3 #x0)

	)
     (sequence ()
	       (set (reg h-registers 14) (add pc (const 4)))
	       (set pc rn6))
     ()
     )


;; Semantics helper pmacros for instructions with 64-bit operands
(define-pmacro (sem-dword-regs-or-exc-1 xrd)
  (and xrd 1)
)
(define-pmacro (sem-dword-regs-or-exc-2 xrd xrn)
  (or (and xrn 1) (sem-dword-regs-or-exc-1 xrd))
)
(define-pmacro (sem-dword-regs-or-exc-3 xrd xrn xrm)
  (or (and xrm 1) (sem-dword-regs-or-exc-2 xrd xrn))
)
(define-pmacro (sem-dword-regs-or-exc xregs sem-op)
  (if (not (%apply (%sym sem-dword-regs-or-exc- (%length xregs)) xregs))
    sem-op
    (schedule-exception (enum H-SCR-STATUS-EXCAUSE-UNALIGNED))
  )
)

;;
(define-pmacro (sem-64bmode-p)
  (not (eq 0 (and (hcr-config) (sll WI 1 (enum H-SCR-CONFIG-64BMODE)))))
)
(define-pmacro (sem-if-64bmode xregs xthen xelse)
  (if (sem-64bmode-p) (sem-dword-regs-or-exc xregs xthen) xelse)
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;  Load/Store Memory Instructions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define-pmacro (sem-memop-or-exc sel addr mem-op)
  (sequence ((BI isAligned))
    (set isAligned
      (case BI sel
        ((OPW_BYTE)   (eq (and addr #x0) #x0))
        ((OPW_SHORT)  (eq (and addr #x1) #x0))
        ((OPW_WORD)   (eq (and addr #x3) #x0))
        (else         (eq (and addr #x7) #x0))))
    (set memaddr addr)
    (if isAligned
      mem-op
      (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-UNALIGNED))
    )
  )
)

;; helper to convert size selector OPW_<mode> into a literal scale factor
(define-pmacro (ConvertSelectorToShift sel scale)
  (set scale
       (case SI sel
	 ((OPW_BYTE)	(const 0))
	 ((OPW_SHORT)	(const 1))
	 ((OPW_WORD)	(const 2))
	 (else	(const 3))))
)

;; common load macros from effective address, handling 8/16/32/64 bits
(define-pmacro (load-double-from-ea regnum eff-addr mode sel)
  (sem-dword-regs-or-exc ((regno regnum))
    (sem-memop-or-exc sel (zext DI eff-addr)
      (set regnum (mem mode (zext DI eff-addr)))
    )
  )
)

(define-pmacro (load-from-ea regnum eff-addr mode sel)
  (sem-memop-or-exc sel (zext DI eff-addr)
    (set regnum (zext SI (mem mode (zext DI eff-addr))))
  )
) ;; 8/16/32 bit cases


;; common store to effective address, handling 8/16/32/64 bit data
(define-pmacro (store-double-to-ea eff-addr regnum mode sel)
  (sem-dword-regs-or-exc ((regno regnum))
    (sem-memop-or-exc sel (zext DI eff-addr)
      (set (mem mode (zext DI eff-addr)) regnum)
    )
  )
)

(define-pmacro (store-to-ea eff-addr regnum mode sel)
  (sem-memop-or-exc sel (zext DI eff-addr)
    (set (mem mode (zext DI eff-addr)) (trunc mode regnum))
  )
) ;8/16/32 bit cases

(define-pmacro (load-insn name mode sel sem-op sfx)
  (%let (
    (rd-op  (%sym rd  sfx))
    (rd6-op (%sym rd6 sfx)))
  (begin
  (dni (%sym name "x16.s")
       (%str "load " mode " indexed")
       (SHORT-INSN)
       (%str name " ${rd" sfx "},[$rn,$rm]")
       (+ OP4_LDSTR16X sel OP_LOAD rd rn rm)
       (sem-if-64bmode ((regno rn-di) (regno rm-di))
         (sem-op rd-op (add DI rn-di rm-di) mode sel)
         (sem-op rd-op (add SI rn rm) mode sel)
       )
       ()
       )

  (dni (%sym name "x.l")
       (%str "load " mode " indexed")
       ()
       (%str name " ${rd6" sfx "},[$rn6,$direction$rm6]")
       (+ OP4_LDSTRX sel OP_LOAD (f-opc-19-4 #x0) (f-dc-22-1 #x0) (f-dc-21-1 #x0) rd6 rn6 direction rm6)
       (sem-if-64bmode ((regno rn6-di) (regno rm6-di))
         (if (ifield f-addsubx)
             (sem-op rd6-op (sub DI rn6-di rm6-di) mode sel)
             (sem-op rd6-op (add DI rn6-di rm6-di) mode sel)
         )
         (if (ifield f-addsubx)
             (sem-op rd6-op (sub SI rn6 rm6) mode sel)
             (sem-op rd6-op (add SI rn6 rm6) mode sel)
         )
       )
       ()
       )

  (dnmi (%sym name "x")
        (%str "load " mode " indexed")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6,$direction$rm6]")
        (emit  (%sym name "x.l") rd6 rn6 direction rm6)
        )

  (dni (%sym name "p16.s")
       (%str "load " mode " postmodify")
       (SHORT-INSN)
       (%str name " ${rd" sfx "},[$rn],$rm")
       (+ OP4_LDSTR16P sel OP_LOAD rd rn rm)
       (sem-if-64bmode ((regno rn-di) (regno rm-di))
         (sequence ((DI rm-save))
           (set rm-save rm-di)
           (sem-op rd-op rn-di mode sel)
           (set rn-di (add DI rn-di rm-save))
         )
         (sequence ((SI rm-save))
           (set rm-save rm)
           (sem-op rd-op rn mode sel)
           (set rn (add SI rn rm-save))
         )
       )
       ()
       )

  (dni (%sym name "p.l")
       (%str "load " mode " postmodify")
       ()
       (%str name " ${rd6" sfx "},[$rn6],$direction$rm6")
       (+ OP4_LDSTRP sel OP_LOAD (f-opc-19-4 #x0) (f-dc-22-2 #x0) rd6 rn6 direction rm6)
       (sem-if-64bmode ((regno rn6-di) (regno rm6-di))
         (sequence ((DI rm6-save))
           (set rm6-save rm6-di)
           (sem-op rd6-op rn6-di mode sel)
           (if (ifield f-addsubx)
             (set rn6-di (sub DI rn6-di rm6-save))
             (set rn6-di (add DI rn6-di rm6-save))
           )
         )
         (sequence ((SI rm6-save))
           (set rm6-save rm6)
           (sem-op rd6-op rn6 mode sel)
           (if (ifield f-addsubx)
             (set rn6 (sub SI rn6 rm6-save))
             (set rn6 (add SI rn6 rm6-save))
           )
         )
       )
       ()
       )

  (dnmi (%sym name "p")
        (%str "load " mode " postmodify")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6],$direction$rm6")
        (emit  (%sym name "p.l") rd6 rn6 direction rm6)
        )

  ;;immediate modes last so reg forms found first.
  (dni (%sym name "d16.s")
       (%str "load " mode " displacement")
       (SHORT-INSN IMM3)
       (%str name " ${rd" sfx "},[$rn,$disp3]")
       (+ OP4_LDSTR16D sel OP_LOAD rd rn disp3) ;; convert size to 'B'
       (sem-if-64bmode ((regno rn-di))
         (sequence ((DI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (set effa (add rn-di (sll disp3 scale)))
           (sem-op rd-op effa mode sel)
         )
         (sequence ((SI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (set effa (add SI rn (sll disp3 scale)))
           (sem-op rd-op effa mode sel)
         )
       )
       ()
       )

  (dni (%sym name "d.l")
       (%str "load " mode " displacement")
       ()
       (%str name " ${rd6" sfx "},[$rn6,$dpmi$disp11]")
       (+ OP4_LDSTRD sel OP_LOAD PMOD_DISP rd6 rn6 dpmi disp11)
       (sem-if-64bmode ((regno rn6-di))
         (sequence ((DI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (if dpmi
             (set effa (sub DI rn6-di (sll disp11 scale)))
             (set effa (add DI rn6-di (sll disp11 scale)))
           )
           (sem-op rd6-op effa mode sel)
         )
         (sequence ((SI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (if dpmi
             (set effa (sub SI rn6 (sll disp11 scale)))
             (set effa (add SI rn6 (sll disp11 scale)))
           )
           (sem-op rd6-op effa mode sel)
         )
       )
       ()
       )

  (dnmi (%sym name "d")
        (%str "load " mode " displacement")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6,$dpmi$disp11]")
        (emit  (%sym name "d.l") rd6 rn6  dpmi disp11)
        )

  (dni (%sym name "dpm.l")
       (%str "load " mode " displacement post-modify")
       ()
       (%str name " ${rd6" sfx "},[$rn6],$dpmi$disp11")
       (+ OP4_LDSTRD sel OP_LOAD PMOD_POST rd6 rn6 dpmi disp11)
       (sem-if-64bmode ((regno rn6-di))
         (sequence ((SI scale))
           (ConvertSelectorToShift sel scale)
           (sem-op rd6-op rn6-di mode sel)
           (if dpmi
             (set rn6 (sub DI rn6-di (sll disp11 scale)))
             (set rn6 (add DI rn6-di (sll disp11 scale)))
           )
         )
         (sequence ((SI scale))
           (ConvertSelectorToShift sel scale)
           (sem-op rd6-op rn6 mode sel)
           (if dpmi
             (set rn6 (sub SI rn6 (sll disp11 scale)))
             (set rn6 (add SI rn6 (sll disp11 scale)))
           )
         )
       )
       ()
       )

  (dnmi (%sym name "dpm")
        (%str "load " mode " displacement post-modify")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6],$dpmi$disp11")
        (emit  (%sym name "dpm.l") rd6 rn6  dpmi disp11)
        )

  ;; macro form with a zero displacement
  (dnmi (%sym name "ds0") "load with 0 disp"
        (SHORT-INSN IMM3)
        (%str name " ${rd" sfx "},[$rn]")
        (emit (%sym name "d16.s") rd rn (disp3 0))
        )
  (dnmi (%sym name "dl0") "load with 0 disp"
        (NO-DIS)
        (%str name " ${rd6" sfx "},[$rn6]")
        (emit (%sym name "d.l") rd6 rn6 (dpmi 0) (disp11 0))
        )
  (dnmi (%sym name "dl0.l") "load with 0 disp"
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6]")
        (emit (%sym name "d.l") rd6 rn6 (dpmi 0) (disp11 0))
        )
  ))
)

(load-insn ldrb QI OPW_BYTE   load-from-ea "")
(load-insn ldrh HI OPW_SHORT  load-from-ea "")
(load-insn ldr  SI OPW_WORD   load-from-ea "")
(load-insn ldrd DI OPW_DOUBLE load-double-from-ea "-di")

;; Wrapper around sem-memop-or-exc that adds the memory write to the trace
(define-pmacro (sem-atomic-memop-or-exc sel addr mem-op)
  (sem-memop-or-exc sel addr
    (sequence ()
      (set-quiet memory-atomic-flag 0)
      mem-op
      (if (eq memory-atomic-flag 1) (set memory-atomic memory-atomic))
    )
  )
)

(define-pmacro (sem-atomic-dw-load-op size ctrlmode cfun)
  (sem-dword-regs-or-exc ((regno rd6))
    (sem-if-64bmode ((regno rn6) (regno rm6))
      (sem-dword-regs-or-exc ((regno rn6) (regno rm6))
        (sequence ((UDI addr))
          (set addr (add DI rn6-di rm6-di))
          (sem-atomic-memop-or-exc size addr
            (set rd6-di (c-call UDI cfun ctrlmode addr size rd6-di))
          )
        )
      )
      (sequence ((UDI addr))
        (set addr (zext DI (add SI rn6 rm6)))
        (sem-atomic-memop-or-exc size addr
          (set rd6-di (c-call UDI cfun ctrlmode addr size rd6-di))
        )
      )
    )
  )
)

(define-pmacro (sem-atomic-load-op size ctrlmode cfun)
  (sem-if-64bmode ((regno rn6) (regno rm6))
    (sem-dword-regs-or-exc ((regno rn6-di) (regno rm6-di))
      (sequence ((UDI addr))
        (set addr (add DI rn6-di rm6-di))
        (sem-atomic-memop-or-exc size addr
          (set rd6 (trunc SI (c-call UDI cfun ctrlmode addr size (zext DI rd6))))
        )
      )
    )
    (sequence ((UDI addr))
      (set addr (zext DI (add SI rn6 rm6)))
      (sem-atomic-memop-or-exc size addr
        (set rd6 (trunc SI (c-call UDI cfun ctrlmode addr size (zext DI rd6))))
      )
    )
  )
)

(define-pmacro (sem-atomic-dw-store-op size ctrlmode cfun)
  (sem-dword-regs-or-exc ((regno rd6))
    (sem-if-64bmode ((regno rn6) (regno rm6))
      (sequence ((UDI addr))
        (set addr (add DI rn6-di rm6-di))
        (sem-dword-regs-or-exc ((regno rn6-di) (regno rm6-di))
          (sem-atomic-memop-or-exc size addr
            (c-call VOID cfun ctrlmode addr size rd6-di)
          )
        )
      )
      (sequence ((UDI addr))
        (set addr (zext DI (add SI rn6 rm6)))
        (sem-atomic-memop-or-exc size addr
          (c-call VOID cfun ctrlmode addr size rd6-di)
        )
      )
    )
  )
)

(define-pmacro (sem-atomic-store-op size ctrlmode cfun)
  (sem-if-64bmode (rn6 rm6)
    (sequence ((UDI addr))
      (set addr (add DI rn6-di rm6-di))
      (sem-dword-regs-or-exc ((regno rn6) (regno rm6))
        (sem-atomic-memop-or-exc size addr
          (c-call VOID cfun ctrlmode addr size (zext DI rd6))
        )
      )
    )
    (sequence ((UDI addr))
      (set addr (zext DI (add SI rn6 rm6)))
      (sem-atomic-memop-or-exc size addr
        (c-call VOID cfun ctrlmode addr size (zext DI rd6))
      )
    )
  )
)

(define-pmacro (sem-atomic-op store size ctrlmode)
  (%if (%equal? (%sym store) OP_STORE)
    (%if (%equal? (%sym size) OPW_DOUBLE)
      (sem-atomic-dw-store-op size ctrlmode "epiphany_atomic_store")
      (sem-atomic-store-op    size ctrlmode "epiphany_atomic_store")
    )
    (%if (%equal? (%sym size) OPW_DOUBLE)
      (sem-atomic-dw-load-op  size ctrlmode "epiphany_atomic_load")
      (sem-atomic-load-op     size ctrlmode "epiphany_atomic_load")
    )
  )
)

(define-pmacro (op-atomic-atomic-size name store ins-sfx op-sfx size)
  (%let (
    (rd6-op (%sym rd6 op-sfx)))
  (begin
    (dni
      (%sym name ins-sfx)
      (%str name ins-sfx)
      () ;; TODO Epiphany-5 attr
      (%str name ins-sfx " ${rd6" op-sfx "},[$rn6,$rm6],$ctrlmode5")
      (+ OP4_LDSTRX store size OPA_ATOMIC rd6 rn6 rm6 ctrlmode5)
      (sem-atomic-op store size ctrlmode5)
      ()
    )
    (dnmi
      (%sym name ins-sfx ".l")
      (%str name ins-sfx ".l")
      (NO-DIS) ;; TODO Epiphany-5 attr
      (%str name ins-sfx ".l ${rd6" op-sfx "},[$rn6,$rm6],$ctrlmode5")
      (emit (%sym name ins-sfx) rd6 rn6 rm6 ctrlmode5)
    )
  ))
)
(define-pmacro (op-atomic-atomic name store)
  (begin
    (op-atomic-atomic-size name store "b" ""    OPW_BYTE)
    (op-atomic-atomic-size name store "h" ""    OPW_SHORT)
    (op-atomic-atomic-size name store ""  ""    OPW_WORD)
    (op-atomic-atomic-size name store "d" "-di" OPW_DOUBLE)
  )
)

(define-pmacro (op-atomic-size name store ctrlmode ins-sfx op-sfx size)
  (%let (
    (rd6-op (%sym rd6 op-sfx)))
  (begin
    (dni
      (%sym name ins-sfx)
      (%str name ins-sfx)
      () ;; TODO Epiphany-5 attr
      (%str name ins-sfx " ${rd6" op-sfx "},[$rn6,$rm6]")
      (+ OP4_LDSTRX store size OPA_ATOMIC rd6 rn6 rm6 ctrlmode)
      (sem-atomic-op store size ctrlmode)
      ()
    )
    (dnmi
      (%sym name ins-sfx ".l")
      (%str name ins-sfx ".l")
      (NO-DIS) ;; TODO Epiphany-5 attr
      (%str name ins-sfx ".l ${rd6" op-sfx "},[$rn6,$rm6]")
      (emit (%sym name ins-sfx) rd6 rn6 rm6)
    )
  ))
)
(define-pmacro (op-atomic-all name store ctrlmode)
  (begin
    (op-atomic-size name store ctrlmode "b" ""    OPW_BYTE)
    (op-atomic-size name store ctrlmode "h" ""    OPW_SHORT)
    (op-atomic-size name store ctrlmode ""  ""    OPW_WORD)
    (op-atomic-size name store ctrlmode "d" "-di" OPW_DOUBLE)
  )
)

;; Test-set is in its own group: OPA_TESTSET
(define-pmacro (op-atomic-testset name mode size)
  (begin
  (dni (%sym name "t")
       (%str "testset " mode " indexed")
       ()
       (%str name " $rd6,[$rn6,${pos-direction}$rm6]")
       (+ OP4_LDSTRX size OP_LOAD OPA_TESTSET (f-opc-19-4 #x0) (f-dc-20-1 #x0) rd6 rn6 rm6)
       (sem-atomic-op OP_LOAD size OP_CTRLMODE_TESTSET)
       ()
       )
  (dnmi (%sym name "t.l")
        (%str "testset " mode ".l indexed")
        (NO-DIS)
        (%str name ".l $rd6,[$rn6,${pos-direction}$rm6]")
        (emit (%sym name "t") rd6 rn6 rm6)
        )
  )
)
(op-atomic-testset testset SI OPW_WORD)


;; need 16 bit forms too
(define-pmacro (store-insn name mode sel sem-op sfx)
  (%let (
    (rd-op  (%sym rd  sfx))
    (rd6-op (%sym rd6 sfx)))
  (begin
  (dni (%sym name "x16")
       (%str "store" mode " indexed")
       (SHORT-INSN)
       (%str name " ${rd" sfx "},[$rn,$rm]")
       (+ OP4_LDSTR16X sel OP_STORE rd rn rm)
       (sem-if-64bmode ((regno rn-di) (regno rm-di))
         (sem-op (add DI rn-di rm-di) rd-op mode sel)
         (sem-op (add SI rn rm) rd-op mode sel)
       )
       ()
       )

  (dni (%sym name "x")
       (%str "store" mode " indexed")
       ()
       (%str name " ${rd6" sfx "},[$rn6,$direction$rm6]")
       (+ OP4_LDSTRX sel OP_STORE (f-opc-19-4 #x0)  (f-dc-22-1 #x0) (f-dc-21-1 #x0) rd6 rn6 direction rm6)
       (sem-if-64bmode ((regno rn6-di) (regno rm6-di))
         (if (ifield f-addsubx)
           (sem-op (sub DI rn6-di rm6-di) rd6-op mode sel)
           (sem-op (add DI rn6-di rm6-di) rd6-op mode sel)
         )
         (if (ifield f-addsubx)
           (sem-op (sub SI rn6 rm6) rd6-op mode sel)
           (sem-op (add SI rn6 rm6) rd6-op mode sel)
         )
       )
       ()
       )

  (dnmi (%sym name "x.l")
        (%str "store" mode " indexed")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6,$direction$rm6]")
        (emit  (%sym name "x")  rd6 rn6 direction rm6)
        )

  (dni (%sym name "p16")
       (%str "store " mode " postmodify")
       (SHORT-INSN)
       (%str name " ${rd" sfx "},[$rn],$rm")
       (+ OP4_LDSTR16P sel OP_STORE rd rn rm)
       (sem-if-64bmode ((regno rn-di) (regno rm-di))
         (sequence ((DI rm-save))
           (set rm-save rm-di)
           (sem-op rn-di rd-op mode sel)
           (set rn-di (add DI rn-di rm-save))
         )
         (sequence ((SI rm-save))
           (set rm-save rm)
           (sem-op rn rd-op mode sel)
           (set rn (add SI rn rm-save))
         )
       )
       ()
       )

  (dni (%sym name "p")
       (%str "store " mode " postmodify")
       ()
       (%str name " ${rd6" sfx "},[$rn6],$direction$rm6")
       (+ OP4_LDSTRP sel OP_STORE (f-opc-19-4 #x0) (f-dc-22-2 #x0) rd6 rn6 direction rm6)
       (sem-if-64bmode ((regno rn6-di) (regno rm6-di))
         (sequence ((DI rm6-save))
           (set rm6-save rm6-di)
           (sem-op rn6-di rd6-op mode sel)
           (if (ifield f-addsubx)
             (set rn6-di (sub DI rn6-di rm6-save))
             (set rn6-di (add DI rn6-di rm6-save))
           )
         )
         (sequence ((SI rm6-save))
           (set rm6-save rm6)
           (sem-op rn6 rd6-op mode sel)
           (if (ifield f-addsubx)
             (set rn6 (sub SI rn6 rm6-save))
             (set rn6 (add SI rn6 rm6-save))
           )
         )
       )
       ()
       )
  (dnmi (%sym name "p.l")
        (%str "store " mode " postmodify")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6],$direction$rm6")
        (emit (%sym name "p") rd6 rn6 direction rm6)
        )

  (dni (%sym name "d16")
       (%str "store " mode " displacement")
       (SHORT-INSN IMM3)
       (%str name " ${rd" sfx "},[$rn,$disp3]")
       (+ OP4_LDSTR16D sel OP_STORE rd rn disp3) ;; convert size to 'B'
       (sem-if-64bmode ((regno rn-di))
         (sequence ((DI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (set effa (add DI rn-di (sll disp3 scale)))
           (sem-op effa rd-op mode sel)
         )
         (sequence ((SI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (set effa (add SI rn (sll disp3 scale)))
           (sem-op effa rd-op mode sel)
         )
       )
       ()
       )

  (dni (%sym name "d")
       (%str "store " mode " displacement")
       ()
       (%str name " ${rd6" sfx "},[$rn6,$dpmi$disp11]")
       (+ OP4_LDSTRD sel OP_STORE PMOD_DISP rd6 rn6 dpmi disp11)
       (sem-if-64bmode ((regno rn6-di))
         (sequence ((DI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (if dpmi
             (set effa (sub DI rn6-di (sll disp11 scale)))
             (set effa (add DI rn6-di (sll disp11 scale)))
           )
           (sem-op effa rd6-op mode sel)
         )
         (sequence ((SI effa) (SI scale))
           (ConvertSelectorToShift sel scale)
           (if dpmi
             (set effa (sub SI rn6 (sll disp11 scale)))
             (set effa (add SI rn6 (sll disp11 scale)))
           )
           (sem-op effa rd6-op mode sel)
         )
       )
       ()
       )

  (dnmi (%sym name "d.l")
        (%str "store " mode " displacement")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6,$dpmi$disp11]")
        (emit (%sym name "d") rd6 rn6 dpmi disp11)
        )

  (dni (%sym name "dpm")
       (%str "store " mode " displacement post-modify")
       ()
       (%str name " ${rd6" sfx "},[$rn6],$dpmi$disp11")
       (+ OP4_LDSTRD sel OP_STORE PMOD_POST rd6 rn6 dpmi disp11) ;; convert size to 'B'
       (sem-if-64bmode ((regno rn6-di))
         (sequence ((SI scale))
           (ConvertSelectorToShift sel scale)
           (sem-op rn6-di rd6-op mode sel)
           (if dpmi
             (set rn6-di (sub DI rn6-di (sll disp11 scale)))
             (set rn6-di (add DI rn6-di (sll disp11 scale)))
           )
         )
         (sequence ((SI scale))
           (ConvertSelectorToShift sel scale)
           (sem-op rn6 rd6-op mode sel)
           (if dpmi
             (set rn6 (sub SI rn6 (sll disp11 scale)))
             (set rn6 (add SI rn6 (sll disp11 scale)))
           )
         )
       )
       ()
       )
  (dnmi (%sym name "dpm.l")
        (%str "store " mode " displacement post-modify")
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6],$dpmi$disp11")
        (emit (%sym name "dpm") rd6 rn6 dpmi disp11)
        )

  ;; macro form with a zero displacement
  (dnmi (%sym name "ds0") "store w 0 disp"
        (SHORT-INSN IMM3)
        (%str name " $rd,[$rn]")
        (emit (%sym name "d16") rd rn (disp3 0))
        )

  (dnmi (%sym name "dl0")  "store w 0 disp"
        ()
        (%str name " ${rd6" sfx "},[$rn6]")
        (emit (%sym name "d") rd6 rn6 (dpmi 0) (disp11 0))
        )

  (dnmi (%sym name "dl0.l")  "store w 0 disp"
        (NO-DIS)
        (%str name ".l ${rd6" sfx "},[$rn6]")
        (emit (%sym name "d") rd6 rn6 (dpmi 0) (disp11 0))
        )
  ))
)
(store-insn strb QI OPW_BYTE   store-to-ea "")
(store-insn strh HI OPW_SHORT  store-to-ea "")
(store-insn str  SI OPW_WORD   store-to-ea "")
(store-insn strd DI OPW_DOUBLE store-double-to-ea "-di")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOV<COND> RD,RN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (move-insns name cond g-op)
  (begin
    (dni (%sym "cmov16" cond)
		 (%str "move register " cond)
		 (SHORT-INSN)
		 (%str "mov" name " $rd,$rn")
		 (+ OP4_FLOW16 (%sym "OPC_" cond) (f-opc-8-1 #x0) (f-dc-9-1 #x0) rd rn)
		 (if (g-op)
		     (set rd rn))
		 ()
		 )

    (dni (%sym "cmov" cond)
		 (%str "move register " cond)
		 ()
		 (%str "mov" name " $rd6,$rn6")
		 (+ OP4_MISC (%sym "OPC_" cond) (f-opc-8-1 #x0) (f-dc-9-1 #x0) (f-opc-19-4 #x2) (f-dc-25-6 #x0) rd6 rn6)
		 (if (g-op)
		     (set rd6 rn6))
		 ()
		 )
    (dnmi (%sym "cmov.l" cond)
	  (%str "move register " cond)
	  (NO-DIS)
	  (%str "mov" name ".l $rd6,$rn6")
	  (emit (%sym "cmov" cond) rd6 rn6)
	  )



    )
  )

					; basic conditional moves
(move-insns "eq"    EQ	   (%pmacro () (eq zbit #x1)))
(move-insns "ne"    NE	   (%pmacro () (eq zbit #x0)))
(move-insns "gtu"   GTU	   (%pmacro () (and BI cbit (not BI zbit))))
(move-insns "gteu"  GTEU   (%pmacro () (eq cbit #x1)))
(move-insns "lteu"  LTEU   (%pmacro () (or BI (not BI cbit) zbit)))
(move-insns "ltu"   LTU	   (%pmacro () (eq cbit #x0)))
(move-insns "gt"    GT	   (%pmacro () (and BI (not BI zbit) (eq vbit nbit))))
(move-insns "gte"   GTE	   (%pmacro () (eq vbit nbit)))
(move-insns "lt"    LT	   (%pmacro () (xor BI vbit nbit)))
(move-insns "lte"   LTE	   (%pmacro () (or BI zbit (xor vbit nbit))))

					; unconditional move
(move-insns ""      B      (%pmacro () #x1))


					; floating point condition codes (floating point instructions)
(move-insns "beq"   BEQ    (%pmacro () (or BI bzbit bzbit)))
(move-insns "bne"   BNE    (%pmacro () (not BI bzbit)))
(move-insns "blt"   BLT    (%pmacro () (and BI bnbit (not bzbit))))
(move-insns "blte"  BLTE   (%pmacro () (or BI bnbit bzbit)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOVTS RD,RN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 16 bits form exists for group zero ( M1 and M0 equals to zero ) only

(dni movts16
	     "move to special reg"
	     (SHORT-INSN)
	     "movts $sn,$rd"
	     (+ OP4_FLOW16 (f-opc-8-5 #x10) (f-dc-9-1 #x0) rd sn) ;; rd is source for movts
	     (set sn rd)
	     ()
	     )

(define-pmacro (op-mmr-movts name sdreg code)
  (begin

    (dni (%sym "movts" name)
		 (%str "move to " name)
		 ()
		 (%str "movts $" sdreg ",$rd6")
		 (+ OP4_MISC (f-dc-7-4 #x0) (f-opc-8-1 #x1) (f-dc-9-1 #x0) (f-opc-19-4 #x2) (f-dc-25-4 #x0) (f-dc-21-2 code) sdreg rd6);; rd is source for movts
		 (set sdreg rd6)
		 ()
		 )

    (dnmi (%sym "movts.l" name)
	  (%str "move to " name)
	  (NO-DIS)
	  (%str "movts.l $" sdreg ",$rd6")
	  (emit (%sym "movts" name) sdreg rd6)
	  )




    )
  )

(op-mmr-movts  6    sn6    #x0)
(op-mmr-movts  dma  sndma  #x1)
(op-mmr-movts  mem  snmem  #x2)
(op-mmr-movts  mesh snmesh #x3)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MODE imm6; arithmetic mode switch
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni
  mode
  "mode"
  () ;; TODO: (attr (MACH epiphany-v))
  "mode $mode4"
  (+ OP4_MISC (f-opc-9-6 #x30) (f-dc-21-2 #x0) (f-opc-19-4 #x2) (f-dc-25-4 #x0) mode4 (f-sn #x0) (f-sn-x #x0) (f-dc-31-2 #x0))
  (set arithmode mode4)
  ()
)
(dnmi
  (mode.l)
  ("mode.l")
  (NO-DIS)
  "mode.l $mode4"
  (emit mode mode4)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MOVFS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni movfs16
	     "move from special register"
	     (SHORT-INSN)
	     "movfs $rd,$sn"
	     (+ OP4_FLOW16 (f-opc-8-5 #x11) (f-dc-9-1 #x0) rd sn)
	     (set rd sn)
	     ()
	     )



(define-pmacro (op-mmr-movfs name snreg code)
  (begin

    (dni (%sym "movfs" name)
		 (%str "move from " name)
		 ()
		 (%str "movfs $rd6,$" snreg)
		 (+ OP4_MISC (f-dc-7-4 #x1) (f-opc-8-1 #x1) (f-dc-9-1 #x0) (f-opc-19-4 #x2) (f-dc-25-4 #x0) (f-dc-21-2 code) rd6 snreg)
		 (set rd6 snreg)
		 ()
		 )

    (dnmi (%sym "movfs.l" name)
	  (%str "move from " name)
	  (NO-DIS)
	  (%str "movfs.l $rd6,$" snreg)
	  (emit (%sym "movfs" name) rd6 snreg)
	  )



    )
  )

(op-mmr-movfs  6    sn6    #x0)
(op-mmr-movfs  dma  sndma  #x1)
(op-mmr-movfs  mem  snmem  #x2)
(op-mmr-movfs  mesh snmesh #x3)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; NOP 0x1a2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni nop
	     "no-operation"
	     (SHORT-INSN)
	     "nop"
	     (+ OP4_FLOW16 (f-opc-8-5 #x1a) (f-dc-15-7 #x0))
	     (nop)
	     ()
	     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SNOP 0x3a2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni snop
	     "no-operation"
	     (SHORT-INSN)
	     "snop"
	     (+ OP4_FLOW16 (f-opc-8-5 #x3a) (f-dc-15-7 #x0))
	     (nop)
	     ()
	     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; UNIMPL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni unimpl
	     "not-implemented"
	     ()
	     "unimpl"
	     (+ (f-opc-31-32  #x000F000F))
	     (nop)
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; IDLE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni idle
  "idle until interrupt"
  (SHORT-INSN)
  "idle"
  (+ OP4_FLOW16 (f-opc-8-5 #x1b) (f-dc-15-7 #x0))
  (sequence ((USI tmpPC))
    (set caibit 0)
    (set tmpPC pc)
    (set pc (add tmpPC (const 2)))
    ;; (%if (mach == epiphany-5)
      (c-call VOID "epiphany_gie" (const 1))
    ;; )
  )
  ()
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; BKPT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni bkpt
     "breakpoint"
     (SHORT-INSN)
     "bkpt"
     (+ OP4_FLOW16 (f-opc-8-5 #x1c) (f-dc-15-7 #x0))
     (sequence ()
     	 (c-call  "epiphany_break" pc)
     	(set pc pc)
     	)
     ()
     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MBKPT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(dni mbkpt
     "multicorebreakpoint"
     (SHORT-INSN)
     "mbkpt"
     (+ OP4_FLOW16 (f-opc-8-5 #x1c) (f-dc-15-7 #x1))
     ;;;(c-call "epiphany_break" pc)
     (nop) ;; ignore the multi core break point in the simulator
     ()
     )

;;;;;;;;;;;;;;;;
;; RTI
;;;;;;;;;;;;;;;;

(dni rti "return from interrupt" (SHORT-INSN UNCOND-CTI)
  "rti"
  (+ OP4_FLOW16 (f-opc-8-5 #x1d) (f-dc-15-7 #x0))
  (sequence ()
	(set pc (c-call USI "epiphany_rti"))
	;(set gidisablebit 0)
	;(set kmbit 0)
	;(set caibit 1)
	;(set pc (hcr-iret))
  )
  ()
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; WAND is a wired flag that runs around the chip
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni wand "wand"
          (SHORT-INSN)
          "wand"
          (+ OP4_FLOW16 (f-opc-8-5 #x18) (f-dc-15-7 #x0))
          (sequence ()
            (set sflagbit 1)
            (c-call VOID "epiphanybf_wand")
          )
          ()
          )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sync likes wand, but wired OR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni sync     "sync"
	     (SHORT-INSN)
	     "sync"
	     (+ OP4_FLOW16 (f-opc-8-5 #x1f) (f-dc-15-7 #x0))
	     (nop);;TODO
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GIE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni gien     "global interrupt enable"
	     (SHORT-INSN)
	     "gie"
	     (+ OP4_FLOW16 (f-gien-gidis-9-1 #x0) (f-opc-8-5 #x19) (f-dc-15-6 #x0))
		 ;; Might trigger interrupt
		 (c-call VOID "epiphany_gie" (const 0))
	     ()
	     )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GIDIS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(dni gidis     "global interrupt disable"
	     (SHORT-INSN)
	     "gid"
	     (+ OP4_FLOW16 (f-gien-gidis-9-1 #x1) (f-opc-8-5 #x19) (f-dc-15-6 #x0))
	     (set gidisablebit 1)
	     ()
	     )



;;;;;;;;;;;;;;;;
;; SWI
;;;;;;;;;;;;;;;;

;; Model only immediate 'fire' exception, if gien cleared or masked don't fire and don't check later - no ilat like behavior
;; TODO: Parameter version seems unsupported by assembler. Remove ?
(dni swi_num "software interrupt" (SHORT-INSN UNCOND-CTI)
     "swi $swi_num"
     (+ OP4_FLOW16 (f-opc-8-5 #x1e) (f-trap-swi-9-1 #x0)  swi_num) ;; What do we do with swi_num?
     (sequence ()  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-SWI)))
     ()
     )
(dni swi "software interrupt" (ALIAS SHORT-INSN UNCOND-CTI)
     "swi"
     (+ OP4_FLOW16 (f-opc-8-5 #x1e) (f-trap-swi-9-1 #x0) (f-dc-15-6 #x0))
     (sequence ()  (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-SWI)))
     ()
     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TRAP #disp3 - simulator only and chip as well - make the same grouop as swi
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Only defining 16-bit form of this instruction.  It exists to support the
;; simulator, by giving us a simple input/output mechanism beyond returning values
;; in registers or memory.
;; TRAP #N  - special sw trap for simulator support;  allows simple i/o using fixed arguments
;; TRAP #0  - write (r0=i/o channel, r1=addr, r2=len) returns status in r0
;; TRAP #1  - read  (r0=i/o channel, r1=addr, r2=len) returns length or -<code> on error
;; TRAP #2  - open  (r0=string path, r1=mode) returns channel# or -<code> on error
;; TRAP #3  - exit  (r0=status code) never returns.
;; TRAP #4  - print "pass\n" and exit
;; TRAP #5  - print "fail\n" and exit
;; TRAP #6  - close  (r0=i/o channel)

(dni trap16 "trap to simulator"
     (SHORT-INSN UNCOND-CTI)
     "trap $trapnum6"
     (+ OP4_FLOW16 (f-opc-8-5 #x1e) (f-trap-swi-9-1 #x1)  trapnum6) ;;  (+ OP4_IMM16 OPI_TRAP (f-rd 0) (f-rn 0) disp3)
     (set (reg SI h-registers 0) (c-call SI "epiphany_trap" pc trapnum6))
     ()
     )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Integer arithmetic instructions 3 address forms
;;   both 16 and 32 bit forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (op-rrr name sem-op cond-op mode)
  (begin
    (dni (%sym name "16")
		 (%str name)
		 (SHORT-INSN)
		 (%str name " $rd,$rn,$rm")
		 (+ OP4_ALU16 (%sym "OPB_" (%upcase (%str name))) rd rn rm)
		 (sequence ()
			   (cond-op mode rn rm)
			   (set rd (sem-op mode rn rm))
			   (set zbit (zflag mode rd))
			   (set nbit (nflag mode rd))
			   )
		 ()
		 )

    (dni (%sym name)
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$rm6")
		 (+ OP4_MISC (%sym "OPB_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-3 #x0) rd6 rn6 rm6)
		 (sequence ()
			   (cond-op mode rn6 rm6)
			   (set rd6 (sem-op mode rn6 rm6))
			   (set zbit (zflag mode rd6))
			   (set nbit (nflag mode rd6))
			   )
		 ()
		 )

    (dnmi (%sym name ".l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$rm6")
	  (emit (%sym name) rd6 rn6 rm6)
	  )
  )
)

;; submacros to set condition codes
;;  NZ are always set to reflect the sign and value of the result
;;  CV are a function of the operator
(define-pmacro (add-vc mode a b) (sequence ()
				      (set cbit (add-cflag mode a b 0))
				      (set vbit (add-oflag mode a b 0))
				      (set vsbit (or BI vsbit vbit))
				      ))

(define-pmacro (sub-vc mode a b) (sequence ()
				      (set cbit (not (sub-cflag mode a b 0)))
				      (set vbit (sub-oflag mode a b 0))
				      (set vsbit (or vsbit vbit))
				      ))

(define-pmacro (logic-vc mode a b) (sequence ()
					(set cbit 0)
					(set vbit 0)
					))

(op-rrr add add add-vc   SI)
(op-rrr sub sub sub-vc   SI)
(op-rrr and and logic-vc SI)
(op-rrr orr or  logic-vc SI)
(op-rrr eor xor logic-vc SI)

;; Integer arithmetic immediate forms

(define-pmacro (op-rri name code cond-op mode)
  (begin
    (dni (%sym name "i16")
		 (%str name)
		 (SHORT-INSN IMM3)
		 (%str name ".s $rd,$rn,$simm3")
		 (+ OP4_IMM16 code rd rn simm3)
		 (sequence ()
			   (cond-op mode rn simm3)
			   (set rd (name mode rn simm3))
			   (set zbit (zflag mode rd))
			   (set nbit (nflag mode rd))
			   )
		 ()
		 )


    (dni (%sym name "i")
		 (%str name)
		 ()
		 (%str name ".l $rd6,$rn6,$simm11")
		 (+ OP4_IMM32 code OPI_25_2_MBZ rd6 rn6 simm11)
		 (sequence ()
			   (cond-op mode rn6 simm11)
			   (set rd6 (name mode rn6 simm11))
			   (set zbit (zflag mode rd6))
			   (set nbit (nflag mode rd6))
			   )
		 ()
		 )

    ;;    (dnmi (%sym name "ri") "relaxed arithmetic immediate" (RELAXED)
    ;;	  (%str name " $rd6,$rn6,$simm11")
    ;;	  (emit (%sym name "i") rd6 rn6 simm11))
    )
  )

(op-rri add OPI_ADD add-vc SI)
(op-rri sub OPI_SUB sub-vc SI)

(dnmi addir "relaxable short immediate add" (RELAXABLE IMM3)
      "add $rd,$rn,$simm3"
      (emit addi16 rd rn simm3))

(dnmi addi32r "relaxed long immediate add" (RELAXED)
      "add $rd6,$rn6,$simm11"
      (emit addi rd6 rn6 simm11))

;; Again, but not relaxable so that full sized registers are handled
(dnmi addi32m "relaxed long immediate add" ()
      "add $rd6,$rn6,$simm11"
      (emit addi rd6 rn6 simm11))


(dnmi subir "relaxable short immediate sub" (RELAXABLE IMM3)
      "sub $rd,$rn,$simm3"
      (emit subi16 rd rn simm3))

(dnmi subi32r "relaxed long immediate sub" (RELAXED)
      "sub $rd6,$rn6,$simm11"
      (emit subi rd6 rn6 simm11))

(dnmi subi32m "relaxed long immediate sub" ()
      "sub $rd6,$rn6,$simm11"
      (emit subi rd6 rn6 simm11))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Shift instructions 3 address forms
;;   both 16 and 32 bit forms
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-pmacro (shift-rrr name sem-op mode)
  (begin
    (dni (%sym name "16")
		 (%str name)
		 (SHORT-INSN)
		 (%str name " $rd,$rn,$rm")
		 (+ OP4_ALU16 (%sym "OPB_" (%upcase (%str name))) rd rn rm)
		 (sequence ()
			   (logic-vc mode rn rm)
			   (set rd (sem-op mode rn (and rm (const 31))))
			   (set zbit (zflag mode rd))
			   (set nbit (nflag mode rd))
			   )
		 ()
		 )

    (dni (%sym name)
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$rm6")
		 (+ OP4_MISC (%sym "OPB_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-3 #x0) rd6 rn6 rm6)
		 (sequence ()
			   (logic-vc mode rn6 rm6)
			   (set rd6 (sem-op mode rn6 (and rm6 (const 31))))
			   (set zbit (zflag mode rd6))
			   (set nbit (nflag mode rd6))
			   )
		 ()
		 )

    (dnmi (%sym name ".l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$rm6")
	  (emit (%sym name) rd6 rn6 rm6)
	  )
  )
)

(shift-rrr asr sra SI)
(shift-rrr lsr srl SI)
(shift-rrr lsl sll SI)

(define-pmacro (op-shift-rri name shortcode f5 longcode sem-op mode)
  (begin
    (dni (%sym name "i16")
		 (%str name)
		 (SHORT-INSN)
		 (%str name " $rd,$rn,$shift")
		 (+ shortcode (f-opc-4-1 f5) rd rn shift)
		 (sequence ()
			   (logic-vc mode rn shift)
			   (set rd (sem-op mode rn shift))
			   (set zbit (zflag mode rd))
			   (set nbit (nflag mode rd))
			   )
		 ()
		 )
    (dni (%sym name "i32")
		 (%str name)
		 ()
		 (%str name " $rd6,$rn6,$shift")
		 (+ OP4_MISC (f-opc-4-1 f5) (f-opc-19-4 longcode) (f-dc-25-6 0) rd6 rn6 shift)
		 (sequence ()
			   (logic-vc mode rn6 shift)
			   (set rd6 (sem-op mode rn6 shift))
			   (set zbit (zflag mode rd6))
			   (set nbit (nflag mode rd6))
			   )
		 ()
		 )

    (dnmi (%sym name "i32.l")
	  (%str name)
	  (NO-DIS)
	  (%str name ".l $rd6,$rn6,$shift")
	  (emit (%sym name "i32") rd6  rn6 shift)
	  )


    )
  )

(op-shift-rri lsr OP4_LSHIFT16 0 #x6 srl SI)
(op-shift-rri lsl OP4_LSHIFT16 1 #x6 sll SI)
(op-shift-rri asr OP4_ASHIFT16 0 #xe sra SI)

;; 64 bit integer ops
(define-pmacro (op64-rrr name sem-op cond-op mode)
  (begin
    (dni
      (%sym name "64")
      (%str name "64")
      () ;; TODO: Add Epiphany-5 attribute
      ;; N.B: Shift register (rm) is a 32-bit register
      (%str name "64 ${rd6-di},${rn6-di},${rm6-di}")
      (+ OP4_MISC (%sym "OPB_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-2 #x0) (f-dc-20-1 #x1) rd6-di rn6-di rm6-di)
      (sem-dword-regs-or-exc ((regno rd6-di) (regno rn6-di) (regno rm6-di))
        (sequence ()
          (cond-op mode rn6-di rm6-di)
          (set rd6-di (sem-op mode rn6-di rm6-di))
          (set zbit (zflag mode rd6-di))
          (set nbit (nflag mode rd6-di))
        )
      )
      ()
    )

    (dnmi
      (%sym name "64.l")
      (%str name "64.l")
      (NO-DIS)
      (%str name "64.l ${rd6-di},${rn6-di},${rm6-di}")
      (emit (%sym name "64") rd6-di rn6-di rm6-di)
    )
  )
)
(op64-rrr add add add-vc   DI)
(op64-rrr sub sub sub-vc   DI)
(op64-rrr and and logic-vc DI)
(op64-rrr orr or  logic-vc DI)
(op64-rrr eor xor logic-vc DI)

;; 64-bit shift instructions
(define-pmacro (shift64-rrr name sem-op mode)
  (begin
    (dni
      (%sym name "64")
      (%str name "64")
      () ;; TODO: Epiphany-5 attr
      ;; N.B: Shift register (rm) is a 32-bit register
      (%str name "64 ${rd6-di},${rn6-di},$rm6")
      (+ OP4_MISC (%sym "OPB_" (%upcase (%str name))) (f-opc-19-4 #xa) (f-dc-22-2 #x0) (f-dc-20-1 #x1) rd6-di rn6-di rm6)
      (sem-dword-regs-or-exc ((regno rd6-di) (regno rn6-di))
        (sequence ()
          (logic-vc mode rn6-di rm6)
          (set rd6-di (sem-op mode rn6-di (and rm6 (const 63))))
          (set zbit (zflag mode rd6-di))
          (set nbit (nflag mode rd6-di))
        )
      )
      ()
    )
    (dnmi
      (%sym name "64.l")
      (%str name "64.l")
      (NO-DIS)
      (%str name "64.l ${rd6-di},${rn6-di},$rm6")
      (emit (%sym name "64") rd6-di rn6-di rm6)
    )
  )
)
(shift64-rrr asr sra DI)
(shift64-rrr lsr srl DI)
(shift64-rrr lsl sll DI)


;; BITR - bitreversal (FFT)
;;
;; From Dr Dobbs et al.
;;
;; unsigned int v;
;; v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1);  ;; swap odd-even bits
;; v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2);  ;; swap pairs
;; v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4);  ;; swap nibbles
;; v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8);  ;; swap bytes
;; v =  (v >> 16)              |  (v               << 16); ;; swap halves
(define-pmacro (bit-reversal dest src)
  (sequence ((SI v))
	    (set v src)
	    (set v (or (and (srl v 1) #x55555555) (sll (and v #x55555555) 1)))
	    (set v (or (and (srl v 2) #x33333333) (sll (and v #x33333333) 2)))
	    (set v (or (and (srl v 4) #x0f0f0f0f) (sll (and v #x0f0f0f0f) 4)))
	    (set v (or (and (srl v 8) #x00ff00ff) (sll (and v #x00ff00ff) 8)))
	    (set v (or      (srl v 16)            (sll      v            16)))
	    (set dest v)
	    ))

(dni bitr16 "bit reverse short"
	     (SHORT-INSN)
	     ("bitr $rd,$rn")
	     (+ OP4_ASHIFT16 (f-opc-4-1 1) rd rn (f-shift 0))
	     (sequence ()
		       (bit-reversal rd rn)
		       (set zbit (zflag SI rd))
		       (set nbit (nflag SI rd))
		       (set cbit 0)
		       (set vbit 0)
		       )
	     ()
	     )

(dni bitr "bit reverse"
	     ()
	     ("bitr $rd6,$rn6")
	     (+ OP4_MISC (f-opc-4-1 1) (f-opc-19-4 #xe) (f-dc-25-6 0) rd6 rn6 (f-shift 0))
	     (sequence ()
		       (bit-reversal rd6 rn6)
		       (set zbit (zflag SI rd6))
		       (set nbit (nflag SI rd6))
		       (set cbit 0)
		       (set vbit 0)
		       )
	     ()
	     )
(dnmi bitrl "bit reverse l"
      (NO-DIS)
      ("bitr.l $rd6,$rn6")
      (emit bitr rd6 rn6)
      )


;; Immediate moves.  The 8 bit form is relaxed if it doesn't fit or is external
;; Move RD,#IMM
(dni mov8
	     "mov imm8"
	     (SHORT-INSN)
	     "mov.b $rd,$imm8"
	     (+ OP4_IMM16 (f-opc-4-1 #x0) rd imm8)
	     (set rd (zext SI imm8))
	     ()
	     )

(dnmi mov8r "mov imm8 relaxable"
      (RELAXABLE)
      "mov $rd,$imm8"
      (emit mov8 rd imm8))

(dni mov16
	     "mov imm16"
	     ()
	     "mov.l $rd6,$imm16"
	     (+ OP4_IMM32 (f-opc-4-1 #x0) (f-opc-19-4 #x2) (f-dc-28-1 #x0) rd6 imm16)
	     (set rd6 (zext SI imm16))
	     ()
	     )

(dnmi mov16r "mov imm16 relaxable"
      ()
      "mov $rd6,$imm16"
      (emit mov16 rd6 imm16))

;; MOVE TO HIGH WORD
(dni movt
	     "movt imm16"
	     ()
	     "movt $rd6,$imm16"
	     (+ OP4_IMM32 (f-opc-4-1 #x0) (f-opc-19-4 #x2) (f-dc-28-1 #x1) rd6 imm16)
	     (set rd6 (or (and SI rd6 (const #xffff)) ; keep low bits of rd
			  (sll SI imm16 (const 16)))) ; replacing just high bits
	     ()
	     )
(dnmi movtl
      "movt imm16"
      (NO-DIS)
      "movt.l $rd6,$imm16"
      (emit movt rd6 imm16)
      )

(define-pmacro (sem-fpu-apply xfn xregs xrd xargs)
  (%splice (%unsplice xfn) (%unsplice (%map (%pmacro (idx)
    (reg xregs idx)) (%splice xrd (%unsplice xargs)
  ))))
)

(define-pmacro (sem-fpu-float-default-flags xtype xsfx xnewrd)
  (sequence ()
    ;;All bits are calculated in C
    (set bzbit (c-call BI (%str "get_epiphany_fzeroflag"      xsfx) xnewrd))
    (set bnbit (c-call BI (%str "get_epiphany_fnegativeflag"  xsfx) xnewrd))
    (set bvbit (c-call BI (%str "get_epiphany_foverflowflag"  xsfx) xnewrd))
    (set bubit (c-call BI (%str "get_epiphany_funderflowflag" xsfx) xnewrd))
    (set bibit (c-call BI (%str "get_epiphany_finvalidflag"   xsfx) xnewrd))
  )
)

(define-pmacro (sem-fpu-float SIMD_P xtype xname xsfx xregs xrd xargs xflags-sem)
  (sequence ((xtype sdtmp) (BI bubit) (BI bibit))
    (set sdtmp
      (sem-fpu-apply
        (c-call xtype (%str "epiphany_f" xname xsfx))
        xregs xrd xargs
      )
    )

    ;; xflags-sem argument allow instructions to override default
    ;; flags semantics. N.B: Won't work for SIMD.
    (%if (%pmacro? xflags-sem)
        (xflags-sem xtype xsfx sdtmp)
        (sem-fpu-float-default-flags xtype xsfx sdtmp)
    )

(%if SIMD_P
    (sequence ((xtype sdtmp2)
               (BI bzbit2) (BI bnbit2) (BI bvbit2) (BI bubit2) (BI bibit2))
      (set sdtmp2
        (sem-fpu-apply
          (c-call xtype (%str "epiphany_f" xname xsfx))
          xregs (add xrd 1) (%map (%pmacro (idx) (add idx 1)) xargs)
        )
      )

      (set bzbit2 (c-call BI (%str "get_epiphany_fzeroflag"      xsfx) sdtmp2))
      (set bnbit2 (c-call BI (%str "get_epiphany_fnegativeflag"  xsfx) sdtmp2))
      (set bvbit2 (c-call BI (%str "get_epiphany_foverflowflag"  xsfx) sdtmp2))
      (set bubit2 (c-call BI (%str "get_epiphany_funderflowflag" xsfx) sdtmp2))
      (set bibit2 (c-call BI (%str "get_epiphany_finvalidflag"   xsfx) sdtmp2))

      ;; All bits are ORed in SIMD mode
      (set bzbit (or bzbit bzbit2))
      (set bnbit (or bnbit bnbit2))
      (set bvbit (or bvbit bvbit2))
      (set bubit (or bubit bubit2))
      (set bibit (or bibit bibit2))

      (set rd6-di (join DI SI sdtmp2 sdtmp))
    )
    (set (reg xregs xrd) sdtmp)
)
    ;; Set sticky bits
    (set bvsbit (or bvsbit bvbit))
    (set busbit (or busbit bubit))
    (set bisbit (or bisbit bibit))

    (if (or (and invexcenbit bisbit)
            (or (and ovfexcenbit bvsbit) (and unexcenbit busbit)))
      (schedule-exception (enum H-SCR-STATUS-EXCAUSE-FPU))
    )
  )
)

(define-pmacro (sem-fpu SF_P DF_P SI_P PLACEHOLDER xname xrd xargs xflags-sem)
  (cond VOID
(%if SF_P
    ((eq arithmode ARITHMODE-SF)
      (sem-fpu-float #f SI xname "" h-registers xrd xargs xflags-sem)
    )
    ((eq 1 0) (error "unreachable"))
)
(%if SF_P
    ((eq arithmode ARITHMODE-SF-SIMD)
      (sem-dword-regs-or-exc (%splice xrd (%unsplice xargs))
        (sem-fpu-float #t SI xname "" h-registers xrd xargs xflags-sem)
      )
    )
    ((eq 1 0) (error "unreachable"))
)
(%if DF_P
    ((eq arithmode ARITHMODE-DF)
      (sem-dword-regs-or-exc (%splice xrd (%unsplice xargs))
        (sem-fpu-float #f DI xname "64" h-registers-di xrd xargs xflags-sem)
      )
    )
    ((eq 1 0) (error "unreachable"))
)
(%if SI_P
    ((eq arithmode ARITHMODE-SI)
      (sequence ((SI sdtmp))
        (set sdtmp
          (sem-fpu-apply
            (c-call SI (%str "epiphany_i" xname))
            h-registers xrd xargs
          )
        )
        ;; carry is not connected inb the design (set bcbit bcbit)
        (set bzbit (zflag SI sdtmp))
        (set bnbit (nflag SI sdtmp))
        (set (reg h-registers xrd) sdtmp)
      )
    )
    ((eq 1 0) (error "unreachable"))
)
    ;; TODO: double / simd
    (else
      (schedule-exception (enum USI H-SCR-STATUS-EXCAUSE-ILLEGAL))
    )
  )
)


;; FLOATING POINT OPERATIONS
;; TWO operands
(define-pmacro (op-two_operands-float name code)
  (begin
    (dni (%sym "f_" name "f16")
         (%str "f_" name)
         (SHORT-INSN)
         (%str "f" name " $rd,$rn,$rm")
         (+ OP4_DSP16 code rd rn rm)
         (sem-fpu #t #t #t #t name f-rd (f-rn f-rm) ())
         ()
         )
    (dnmi (%sym "i_" name "f16")
          (%str "i_" name)
          (SHORT-INSN NO-DIS)
          (%str "i" name " $rd,$rn,$rm")
          (emit (%sym "f_" name "f16") rd rn rm)
          )
    (dnmi (%sym "f64_" name ".s") ;; 64-bit float
          (%str "f64_" name ".s")
          (SHORT-INSN NO-DIS)
          (%str "f" name "64 $rd,$rn,$rm")
          (emit (%sym "f_" name "f16") rd rn rm)
          )
    ;; long insns
    (dni (%sym "f_" name "f32")
         (%str "f_" name)
         ()
         (%str "f" name " $rd6,$rn6,$rm6")
         (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rm6)
         (sem-fpu #t #t #t #t name f-rd6 (f-rn6 f-rm6) ())
         ()
         )
    (dnmi (%sym "f_" name "f32.l")
          (%str "f_" name)
          (NO-DIS)
          (%str "f" name ".l $rd6,$rn6,$rm6")
          (emit  (%sym "f_" name "f32") rd6  rn6 rm6)
          )
    (dnmi (%sym "i_" name "f32")
          (%str "i_" name)
          (NO-DIS)
          (%str "i" name " $rd6,$rn6,$rm6")
          (emit  (%sym "f_" name "f32") rd6  rn6 rm6)
          )
    (dnmi (%sym "i_" name "f32.l")
          (%str "i_" name)
          (NO-DIS)
          (%str "i" name ".l $rd6,$rn6,$rm6")
          (emit  (%sym "f_" name "f32") rd6  rn6 rm6)
          )
    (dnmi (%sym "f64_" name) ;; 64-bit float (double)
          (%str "f64_" name)
          (NO-DIS)
          (%str "f" name "64 ${rd6-di},${rn6-di},${rm6-di}")
          (emit (%sym "f_" name "f32") rd6  rn6 rm6)
          )
    (dnmi (%sym "f64_" name ".l") ;; 64-bit float (double) ".l"
          (%str "f64_" name ".l")
          (NO-DIS)
          (%str "f" name "64.l ${rd6-di},${rn6-di},${rm6-di}")
          (emit (%sym "f_" name "f32") rd6  rn6 rm6)
          )
  )
)
(op-two_operands-float add OPF_ADD)
(op-two_operands-float sub OPF_SUB)
(op-two_operands-float mul OPF_MUL)
(op-two_operands-float madd OPF_MADD)
(op-two_operands-float msub OPF_MSUB)

;; ONE operands
;; FABS

(define-pmacro (op-fabs-float name code)
  (begin
    (dni (%sym "f_" name "f16")
         (%str "f_" name)
         (SHORT-INSN)
         (%str "f" name " rd,rn")
         (+ OP4_DSP16 code rd rn rn)
         (sem-fpu #t #t #f #f name f-rd (f-rn) ())
         ()
         )
    (dni (%sym "f_" name "f32")
         (%str "f_" name)
         ()
         (%str "f" name " $rd6,$rn6")
         (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rn6)
         (sem-fpu #t #t #f #f name f-rd6 (f-rn6) ())
         ()
         )
    (dnmi (%sym "f_" name "f32.l")
          (%str "f_" name)
          (NO-DIS)
          (%str "f" name ".l $rd6,$rn6")
          (emit (%sym "f_" name "f32") rd6  rn6)
          )
  )
)
(op-fabs-float abs OPF_FABS)

(define-pmacro (op-fix2float-float name code)
  (begin
    (dni (%sym "f_" name "f16")
         (%str "f_" name)
         (SHORT-INSN)
         (%str "f" name " $rd,$rn")
         (+ OP4_DSP16 code rd rn rn)
         (sem-fpu #t #f #f #f name f-rd (f-rn) ())
         ()
         )
    (dni (%sym "f_" name "f32")
         (%str "f_" name)
         ()
         (%str "f" name " $rd6,$rn6")
         (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rn6)
         (sem-fpu #t #f #f #f name f-rd6 (f-rn6) ())
         ()
         )
    (dnmi (%sym "f_" name "f32.l")
          (%str "f_" name)
          (NO-DIS)
          (%str "f" name ".l $rd6,$rn6")
          (emit (%sym "f_" name "f32")  rd6 rn6)
          )
  )
)
(op-fix2float-float loat OPF_FLOAT)

(define-pmacro (sem-float2fix-flags xtype xsfx xnewrd)
  (sequence ()
    (set bzbit (zflag xtype xnewrd))
    (set bnbit (nflag xtype xnewrd))
    (set bvbit (c-call BI (%str "get_epiphany_foverflowflag"  xsfx) xnewrd))
    (set bubit (c-call BI (%str "get_epiphany_funderflowflag" xsfx) xnewrd))
    (set bibit (c-call BI (%str "get_epiphany_finvalidflag"   xsfx) xnewrd))
  )
)

(define-pmacro (op-float2fix-float name code)
  (begin
    (dni (%sym "f_" name "f16")
         (%str "f_" name)
         (SHORT-INSN)
         (%str "f" name " $rd,$rn")
         (+ OP4_DSP16 code rd rn rn)
         (sem-fpu #t #f #f #f name f-rd (f-rn) sem-float2fix-flags)
         ()
         )
    (dni (%sym "f_" name "f32")
         (%str "f_" name)
         ()
         (%str "f" name " $rd6,$rn6")
         (+ OP4_MISC code (f-opc-19-4 #x7) (f-dc-22-3 #x0) rd6 rn6 rn6)
         (sem-fpu #t #f #f #f name f-rd6 (f-rn6) sem-float2fix-flags)
         ()
         )
    (dnmi (%sym "f_" name "f32.l")
          (%str "f_" name)
          (NO-DIS)
          (%str "f" name ".l $rd6,$rn6")
          (emit (%sym "f_" name "f32") rd6  rn6)
          )
  )
)
(op-float2fix-float ix OPF_FIX)

;; FMAX
(dni
  fmax
  "fmax"
  () ;; TODO: Epiphany-5 attrib
  ("fmax $rd6,$rn6,$rm6")
  (+ OP4_MISC OPF_FMAX (f-opc-21-6 #x17) (f-dc-22-1 #x0) rd6 rn6 rm6)
  (sem-fpu #t #t #f #f max f-rd6 (f-rn6 f-rm6) ())
  ()
)
(%for-each (%pmacro (name sfx) (%exec
    (dnmi
      (%sym name)
      (%str name)
      (NO-DIS)
      (%str name " ${rd6" sfx "},${rn6" sfx "},${rm6" sfx "}")
      (emit fmax rd6 rn6 rm6)
    )
  ))
  (fmax.l fmax64 fmax64.l) ("" "-di" "-di")
)
